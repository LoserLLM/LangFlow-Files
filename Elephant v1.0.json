{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-4uvfb",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "LMStudioModel-3OpXe",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ChatInput-4uvfb{œdataTypeœ:œChatInputœ,œidœ:œChatInput-4uvfbœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-LMStudioModel-3OpXe{œfieldNameœ:œinput_valueœ,œidœ:œLMStudioModel-3OpXeœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-4uvfb",
        "sourceHandle": "{œdataTypeœ:œChatInputœ,œidœ:œChatInput-4uvfbœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "target": "LMStudioModel-3OpXe",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œLMStudioModel-3OpXeœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "LMStudioModel",
            "id": "LMStudioModel-3OpXe",
            "name": "model_output",
            "output_types": [
              "LanguageModel"
            ]
          },
          "targetHandle": {
            "fieldName": "agent_llm",
            "id": "Agent-zrOq9",
            "inputTypes": [
              "LanguageModel"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__LMStudioModel-3OpXe{œdataTypeœ:œLMStudioModelœ,œidœ:œLMStudioModel-3OpXeœ,œnameœ:œmodel_outputœ,œoutput_typesœ:[œLanguageModelœ]}-Agent-zrOq9{œfieldNameœ:œagent_llmœ,œidœ:œAgent-zrOq9œ,œinputTypesœ:[œLanguageModelœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "LMStudioModel-3OpXe",
        "sourceHandle": "{œdataTypeœ:œLMStudioModelœ,œidœ:œLMStudioModel-3OpXeœ,œnameœ:œmodel_outputœ,œoutput_typesœ:[œLanguageModelœ]}",
        "target": "Agent-zrOq9",
        "targetHandle": "{œfieldNameœ:œagent_llmœ,œidœ:œAgent-zrOq9œ,œinputTypesœ:[œLanguageModelœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-zrOq9",
            "name": "response",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-ED2VZ",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__Agent-zrOq9{œdataTypeœ:œAgentœ,œidœ:œAgent-zrOq9œ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-ED2VZ{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-ED2VZœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Agent-zrOq9",
        "sourceHandle": "{œdataTypeœ:œAgentœ,œidœ:œAgent-zrOq9œ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-ED2VZ",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-ED2VZœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "PlaywrightWorkflow",
            "id": "CustomComponent-PUNPu",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-zrOq9",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-PUNPu{œdataTypeœ:œPlaywrightWorkflowœ,œidœ:œCustomComponent-PUNPuœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-zrOq9{œfieldNameœ:œtoolsœ,œidœ:œAgent-zrOq9œ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-PUNPu",
        "sourceHandle": "{œdataTypeœ:œPlaywrightWorkflowœ,œidœ:œCustomComponent-PUNPuœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-zrOq9",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-zrOq9œ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "CodeRunnerTool",
            "id": "CustomComponent-RBhOR",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-zrOq9",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-RBhOR{œdataTypeœ:œCodeRunnerToolœ,œidœ:œCustomComponent-RBhORœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-zrOq9{œfieldNameœ:œtoolsœ,œidœ:œAgent-zrOq9œ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-RBhOR",
        "sourceHandle": "{œdataTypeœ:œCodeRunnerToolœ,œidœ:œCustomComponent-RBhORœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-zrOq9",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-zrOq9œ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "FileSystemTool",
            "id": "CustomComponent-HzERS",
            "name": "api_build_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-zrOq9",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-HzERS{œdataTypeœ:œFileSystemToolœ,œidœ:œCustomComponent-HzERSœ,œnameœ:œapi_build_toolœ,œoutput_typesœ:[œToolœ]}-Agent-zrOq9{œfieldNameœ:œtoolsœ,œidœ:œAgent-zrOq9œ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-HzERS",
        "sourceHandle": "{œdataTypeœ:œFileSystemToolœ,œidœ:œCustomComponent-HzERSœ,œnameœ:œapi_build_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-zrOq9",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-zrOq9œ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "ChatInput-4uvfb",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "inputs",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files",
              "background_color",
              "chat_icon",
              "text_color"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatInput",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Chat Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.0020353564437605998,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-input\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Chat Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        # Ensure files is a list and filter out empty/None values\n        files = self.files if self.files else []\n        if files and not isinstance(files, list):\n            files = [files]\n        files = [f for f in files if f is not None and f != \"\"]\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=files,\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "csv",
                  "json",
                  "pdf",
                  "txt",
                  "md",
                  "mdx",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Input Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "selected_output": "message",
          "showNode": false,
          "type": "ChatInput"
        },
        "dragging": false,
        "id": "ChatInput-4uvfb",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 1230.2648100602037,
          "y": -659.8489413606464
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-ED2VZ",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "outputs",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatOutput",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.003169567463043492,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, _icon, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-ED2VZ",
        "measured": {
          "height": 48,
          "width": 192
        },
        "position": {
          "x": 2965.152121171888,
          "y": -895.0727082805007
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "LMStudioModel-3OpXe",
          "node": {
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "beta": false,
            "category": "lmstudio",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Generate text using LM Studio Local LLMs.",
            "display_name": "LM Studio",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "system_message",
              "stream",
              "max_tokens",
              "model_kwargs",
              "model_name",
              "base_url",
              "api_key",
              "temperature",
              "seed"
            ],
            "frozen": false,
            "icon": "LMStudio",
            "key": "LMStudioModel",
            "last_updated": "2025-11-03T05:24:59.221Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {
              "keywords": [
                "model",
                "llm",
                "language model",
                "large language model"
              ]
            },
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Model Response",
                "group_outputs": false,
                "method": "text_response",
                "name": "text_output",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Language Model",
                "group_outputs": false,
                "method": "build_model",
                "name": "model_output",
                "options": null,
                "required_inputs": null,
                "selected": "LanguageModel",
                "tool_mode": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 5.181793099517413e-13,
            "template": {
              "_type": "Component",
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": true,
                "display_name": "LM Studio API Key",
                "dynamic": false,
                "info": "The LM Studio API Key to use for LM Studio.",
                "input_types": [],
                "load_from_db": false,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "base_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Base URL",
                "dynamic": false,
                "info": "Endpoint of the LM Studio API. Defaults to 'http://localhost:1234/v1' if not specified.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "base_url",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "http://192.168.50.117:1234/v1"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from typing import Any\nfrom urllib.parse import urljoin\n\nimport httpx\nfrom langchain_openai import ChatOpenAI\nfrom typing_extensions import override\n\nfrom langflow.base.models.model import LCModelComponent\nfrom langflow.field_typing import LanguageModel\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.inputs.inputs import DictInput, DropdownInput, FloatInput, IntInput, SecretStrInput, StrInput\n\n\nclass LMStudioModelComponent(LCModelComponent):\n    display_name = \"LM Studio\"\n    description = \"Generate text using LM Studio Local LLMs.\"\n    icon = \"LMStudio\"\n    name = \"LMStudioModel\"\n\n    @override\n    async def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None):\n        if field_name == \"model_name\":\n            base_url_dict = build_config.get(\"base_url\", {})\n            base_url_load_from_db = base_url_dict.get(\"load_from_db\", False)\n            base_url_value = base_url_dict.get(\"value\")\n            if base_url_load_from_db:\n                base_url_value = await self.get_variables(base_url_value, field_name)\n            elif not base_url_value:\n                base_url_value = \"http://localhost:1234/v1\"\n            build_config[\"model_name\"][\"options\"] = await self.get_model(base_url_value)\n\n        return build_config\n\n    @staticmethod\n    async def get_model(base_url_value: str) -> list[str]:\n        try:\n            url = urljoin(base_url_value, \"/v1/models\")\n            async with httpx.AsyncClient() as client:\n                response = await client.get(url)\n                response.raise_for_status()\n                data = response.json()\n\n                return [model[\"id\"] for model in data.get(\"data\", [])]\n        except Exception as e:\n            msg = \"Could not retrieve models. Please, make sure the LM Studio server is running.\"\n            raise ValueError(msg) from e\n\n    inputs = [\n        *LCModelComponent._base_inputs,\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n            range_spec=RangeSpec(min=0, max=128000),\n        ),\n        DictInput(name=\"model_kwargs\", display_name=\"Model Kwargs\", advanced=True),\n        DropdownInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            advanced=False,\n            refresh_button=True,\n        ),\n        StrInput(\n            name=\"base_url\",\n            display_name=\"Base URL\",\n            advanced=False,\n            info=\"Endpoint of the LM Studio API. Defaults to 'http://localhost:1234/v1' if not specified.\",\n            value=\"http://localhost:1234/v1\",\n        ),\n        SecretStrInput(\n            name=\"api_key\",\n            display_name=\"LM Studio API Key\",\n            info=\"The LM Studio API Key to use for LM Studio.\",\n            advanced=True,\n            value=\"LMSTUDIO_API_KEY\",\n        ),\n        FloatInput(\n            name=\"temperature\",\n            display_name=\"Temperature\",\n            value=0.1,\n            advanced=True,\n        ),\n        IntInput(\n            name=\"seed\",\n            display_name=\"Seed\",\n            info=\"The seed controls the reproducibility of the job.\",\n            advanced=True,\n            value=1,\n        ),\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        lmstudio_api_key = self.api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        max_tokens = self.max_tokens\n        model_kwargs = self.model_kwargs or {}\n        base_url = self.base_url or \"http://localhost:1234/v1\"\n        seed = self.seed\n\n        return ChatOpenAI(\n            max_tokens=max_tokens or None,\n            model_kwargs=model_kwargs,\n            model=model_name,\n            base_url=base_url,\n            api_key=lmstudio_api_key,\n            temperature=temperature if temperature is not None else 0.1,\n            seed=seed,\n        )\n\n    def _get_exception_message(self, e: Exception):\n        \"\"\"Get a message from an LM Studio exception.\n\n        Args:\n            e (Exception): The exception to get the message from.\n\n        Returns:\n            str: The message from the exception.\n        \"\"\"\n        try:\n            from openai import BadRequestError\n        except ImportError:\n            return None\n        if isinstance(e, BadRequestError):\n            message = e.body.get(\"message\")\n            if message:\n                return message\n        return None\n"
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tokens",
                "placeholder": "",
                "range_spec": {
                  "max": 128000,
                  "min": 0,
                  "step": 0.1,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "model_kwargs": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Model Kwargs",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "model_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "dict",
                "value": {}
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "external_options": {},
                "info": "",
                "name": "model_name",
                "options": [
                  "mlx-community/gpt-oss-20b",
                  "qwen3-next-80b-a3b-instruct",
                  "mlx-community/qwen3-coder-30b-a3b-instruct",
                  "mlx-community/qwq-32b",
                  "grok-2",
                  "kimi-linear-48b-a3b-instruct@6bit",
                  "minimax-m2@8bit",
                  "kimi-linear-48b-a3b-instruct@8bit",
                  "minimax-m2@4bit",
                  "qwen/qwen3-vl-4b",
                  "kimi-k2-instruct-0905-mlx",
                  "mistralai/magistral-small",
                  "mistralai/magistral-small-2509",
                  "ibm/granite-4-h-tiny",
                  "baidu/ernie-4.5-21b-a3b",
                  "qwen/qwen2.5-vl-7b",
                  "google/gemma-3-4b",
                  "qwen/qwen3-4b-2507",
                  "meta/llama-3.3-70b",
                  "glm-4.5-air-mlx",
                  "qwen/qwen3-next-80b",
                  "qwen/qwen3-vl-30b",
                  "qwen/qwen3-30b-a3b-2507",
                  "glm-4.5-air",
                  "thudm_glm-4-32b-0414",
                  "glm-4.6@q4_k_s",
                  "glm-4.6@q8_k_xl",
                  "glm-z1-rumination-32b-0414",
                  "mistralai/mistral-7b-instruct-v0.3",
                  "google/gemma-3-27b",
                  "qwen/qwen3-vl-8b",
                  "bytedance/seed-oss-36b",
                  "ling-1t-mlx-dq3_k_m",
                  "ling-1t",
                  "qwen3-30b-a3b",
                  "text-embedding-nomic-embed-text-v1.5",
                  "qwen3-30b-a3b-instruct-2507",
                  "deepseek-r1-distill-llama-8b@bf16",
                  "deepseek-r1-distill-llama-8b@q4_k_s",
                  "deepseek-r1-0528-qwen3-8b@bf16",
                  "deepseek-r1-0528-qwen3-8b@q4_k_s",
                  "unsloth/gpt-oss-120b",
                  "ui-tars-72b-dpo@q3_k_l",
                  "ui-tars-72b-dpo@q4_k_m",
                  "ui-tars-72b-dpo@q6_k",
                  "ui-tars-72b-dpo@q8_0",
                  "ui-tars-7b-sft@q4_1",
                  "ui-tars-7b-sft@q4_k_s",
                  "ui-tars-7b-sft@q5_k_m",
                  "ui-tars-7b-sft@q5_k_s",
                  "ui-tars-7b-sft@q6_k",
                  "ui-tars-7b-sft@q6_k_l",
                  "ui-tars-7b-sft@q8_0",
                  "ui-tars-7b-sft@f16",
                  "ui-tars-7b-sft@f32",
                  "ui-tars-72b-dpo@?",
                  "deepseek-r1@q3_k_m",
                  "deepseek-r1@q4_k_m",
                  "ui-tars-72b-dpo-i1",
                  "mlx-community/gpt-oss-120b",
                  "ui-tars-72b-dpo@6bit",
                  "ui-tars-72b-dpo@8bit",
                  "openai_gpt-oss-20b-coder-neo-code-di-matrix",
                  "ui-tars-72b-dpo@4bit",
                  "unsloth/seed-oss-36b-instruct",
                  "longcat-flash-chat",
                  "mlx-community/ui-tars-1.5-7b",
                  "gemmasutra-pro-27b-v1.1",
                  "mungert/ui-tars-1.5-7b",
                  "lmstudio-community/gemma-3-12b-it",
                  "unsloth/gemma-3-12b-it",
                  "openhands-lm-32b-v0.1",
                  "all-hands_openhands-lm-32b-v0.1",
                  "lmstudio-community/r1-1776",
                  "glm-4.5",
                  "exaone-4.0.1-32b",
                  "qwen3-235b-a22b-instruct-2507",
                  "internvl3_5-30b-a3b",
                  "hermes-4-405b-mlx",
                  "cogito-v2-preview-llama-109b-moe",
                  "mindlink-32b-0801",
                  "lmstudio-community/llama-4-scout-17b-16e-instruct",
                  "meta-llama-3-70b-instruct",
                  "mlx-community/qwen3-coder-480b-a35b-instruct",
                  "xwin-lm-70b-v0.1",
                  "deepseek-r1-distill-qwen-32b-abliterated",
                  "lmstudio-community/meta-llama-3.1-8b-instruct",
                  "nousresearch/hermes-4-70b",
                  "qwen3-4b-instruct-2507",
                  "wizardcoder-python-34b-v1.0",
                  "kimi-k2-instruct-q2ks-mixed-autoround",
                  "unsloth/r1-1776",
                  "kimi-k2-instruct-dq4_k",
                  "mlx-community/kimi-k2-instruct",
                  "mlx-community/deepseek-v3.1",
                  "kimi-dev-72b",
                  "starcoder",
                  "deepseek-v3.1-mlx-5",
                  "kimi-k2-instruct-mlx-3",
                  "deepseek-v3-0324",
                  "deepseek-r1-distill-qwen-32b-mlx",
                  "qwen/qwen3-235b-a22b-2507",
                  "codellama-70b-instruct-hf-mlx",
                  "mistralai/mistral-small-3.2",
                  "google/gemma-3n-e4b",
                  "qwen/qwq-32b",
                  "mistralai/devstral-small-2505",
                  "qwen/qwen2.5-coder-14b",
                  "deepseek/deepseek-r1-0528-qwen3-8b",
                  "qwen/qwen3-coder-30b",
                  "microsoft/phi-4-reasoning-plus",
                  "liquid/lfm2-1.2b",
                  "qwen/qwen3-coder-480b",
                  "deepseek-v3.1@q3_k_m",
                  "deepseek-v3.1@q3_k_s",
                  "qwen3-coder-30b-a3b-instruct-480b-distill-v2",
                  "qwen2.5-vl-7b-instruct@bf16",
                  "qwen2.5-vl-7b-instruct@q4_k_s",
                  "cydonia-24b-v4.1",
                  "huihui-gpt-oss-20b-abliterated",
                  "mlx-community/deepseek-r1",
                  "lfm2-vl-1.6b",
                  "lfm2-vl-450m",
                  "jan-v1-4b",
                  "deepseek-r1-distill-qwen-32b",
                  "llama-3-8b-lexi-uncensored",
                  "qwq-32b@q4_k_m",
                  "bartowski/meta-llama-3.1-8b-instruct",
                  "hermes-2-pro-mistral-7b",
                  "omnivlm-968m",
                  "unsloth/qwen3-coder-480b-a35b-instruct",
                  "unsloth/gpt-oss-20b",
                  "unsloth/kimi-k2-instruct",
                  "openai_gpt-oss-120b-neo-imatrix",
                  "llama-4-maverick-17b-128e-instruct",
                  "security-attacks-mitre",
                  "openai-gpt-oss-20b-abliterated-uncensored-neo-imatrix",
                  "unsloth/llama-4-scout-17b-16e-instruct",
                  "deepseek-v3",
                  "llama-3.2-3b-instruct",
                  "openai/gpt-oss-120b",
                  "unsloth/qwen3-coder-30b-a3b-instruct",
                  "gemma-3-270m-it",
                  "meta-llama-3-8b-instruct",
                  "openai/gpt-oss-20b",
                  "qwen/qwen3-4b-thinking-2507"
                ],
                "options_metadata": [],
                "placeholder": "",
                "refresh_button": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "qwen3-next-80b-a3b-instruct"
              },
              "seed": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Seed",
                "dynamic": false,
                "info": "The seed controls the reproducibility of the job.",
                "list": false,
                "list_add_label": "Add More",
                "name": "seed",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "stream": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Stream",
                "dynamic": false,
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "list_add_label": "Add More",
                "name": "stream",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "system_message": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "System Message",
                "dynamic": false,
                "info": "System message to pass to the model.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "temperature": {
                "_input_type": "FloatInput",
                "advanced": true,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "temperature",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": 0.1
              }
            },
            "tool_mode": false
          },
          "selected_output": "model_output",
          "showNode": true,
          "type": "LMStudioModel"
        },
        "dragging": false,
        "id": "LMStudioModel-3OpXe",
        "measured": {
          "height": 449,
          "width": 320
        },
        "position": {
          "x": 2163.9024444211414,
          "y": -688.1699498364009
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Agent-zrOq9",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "Agent",
            "documentation": "https://docs.langflow.org/agents",
            "edited": false,
            "field_order": [
              "agent_llm",
              "max_tokens",
              "model_kwargs",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout",
              "system_prompt",
              "n_messages",
              "format_instructions",
              "output_schema",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "last_updated": "2025-11-04T01:44:11.215Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response",
                "group_outputs": false,
                "method": "message_response",
                "name": "response",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "agent_llm": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Language Model",
                "dynamic": false,
                "external_options": {
                  "fields": {
                    "data": {
                      "node": {
                        "display_name": "Connect other models",
                        "icon": "CornerDownLeft",
                        "name": "connect_other_models"
                      }
                    }
                  }
                },
                "info": "The provider of the language model that the agent will use to generate responses.",
                "input_types": [
                  "LanguageModel"
                ],
                "name": "agent_llm",
                "options": [
                  "Anthropic",
                  "Google Generative AI",
                  "OpenAI"
                ],
                "options_metadata": [
                  {
                    "icon": "Anthropic"
                  },
                  {
                    "icon": "GoogleGenerativeAI"
                  },
                  {
                    "icon": "OpenAI"
                  }
                ],
                "placeholder": "Awaiting model input.",
                "real_time_refresh": true,
                "refresh_button": false,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import json\nimport re\n\nfrom langchain_core.tools import StructuredTool\nfrom pydantic import ValidationError\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.base.agents.events import ExceptionWithMessageError\nfrom langflow.base.models.model_input_constants import (\n    ALL_PROVIDER_FIELDS,\n    MODEL_DYNAMIC_UPDATE_FIELDS,\n    MODEL_PROVIDERS_DICT,\n    MODELS_METADATA,\n)\nfrom langflow.base.models.model_utils import get_model_name\nfrom langflow.components.helpers.current_date import CurrentDateComponent\nfrom langflow.components.helpers.memory import MemoryComponent\nfrom langflow.components.langchain_utilities.tool_calling import (\n    ToolCallingAgentComponent,\n)\nfrom langflow.custom.custom_component.component import _get_component_toolkit\nfrom langflow.custom.utils import update_component_build_config\nfrom langflow.field_typing import Tool\nfrom langflow.helpers.base_model import build_model_from_schema\nfrom langflow.io import (\n    BoolInput,\n    DropdownInput,\n    IntInput,\n    MultilineInput,\n    Output,\n    TableInput,\n)\nfrom langflow.logging import logger\nfrom langflow.schema.data import Data\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.schema.message import Message\nfrom langflow.schema.table import EditMode\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nMODEL_PROVIDERS_LIST = [\"Anthropic\", \"Google Generative AI\", \"OpenAI\"]\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    documentation: str = \"https://docs.langflow.org/agents\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    # Filter out json_mode from OpenAI inputs since we handle structured output differently\n    openai_inputs_filtered = [\n        input_field\n        for input_field in MODEL_PROVIDERS_DICT[\"OpenAI\"][\"inputs\"]\n        if not (hasattr(input_field, \"name\") and input_field.name == \"json_mode\")\n    ]\n\n    inputs = [\n        DropdownInput(\n            name=\"agent_llm\",\n            display_name=\"Model Provider\",\n            info=\"The provider of the language model that the agent will use to generate responses.\",\n            options=[*MODEL_PROVIDERS_LIST],\n            value=\"OpenAI\",\n            real_time_refresh=True,\n            refresh_button=False,\n            input_types=[],\n            options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST],\n            external_options={\n                \"fields\": {\n                    \"data\": {\n                        \"node\": {\n                            \"name\": \"connect_other_models\",\n                            \"display_name\": \"Connect other models\",\n                            \"icon\": \"CornerDownLeft\",\n                        }\n                    }\n                },\n            },\n        ),\n        *openai_inputs_filtered,\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        IntInput(\n            name=\"n_messages\",\n            display_name=\"Number of Chat History Messages\",\n            value=100,\n            info=\"Number of chat history messages to retrieve.\",\n            advanced=True,\n            show=True,\n        ),\n        MultilineInput(\n            name=\"format_instructions\",\n            display_name=\"Output Format Instructions\",\n            info=\"Generic Template for structured output formatting. Valid only with Structured response.\",\n            value=(\n                \"You are an AI that extracts structured JSON objects from unstructured text. \"\n                \"Use a predefined schema with expected types (str, int, float, bool, dict). \"\n                \"Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. \"\n                \"Fill missing or ambiguous values with defaults: null for missing values. \"\n                \"Remove exact duplicates but keep variations that have different field values. \"\n                \"Always return valid JSON in the expected format, never throw errors. \"\n                \"If multiple objects can be extracted, return them all in the structured format.\"\n            ),\n            advanced=True,\n        ),\n        TableInput(\n            name=\"output_schema\",\n            display_name=\"Output Schema\",\n            info=(\n                \"Schema Validation: Define the structure and data types for structured output. \"\n                \"No validation if no output schema.\"\n            ),\n            advanced=True,\n            required=False,\n            value=[],\n            table_schema=[\n                {\n                    \"name\": \"name\",\n                    \"display_name\": \"Name\",\n                    \"type\": \"str\",\n                    \"description\": \"Specify the name of the output field.\",\n                    \"default\": \"field\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n                {\n                    \"name\": \"description\",\n                    \"display_name\": \"Description\",\n                    \"type\": \"str\",\n                    \"description\": \"Describe the purpose of the output field.\",\n                    \"default\": \"description of field\",\n                    \"edit_mode\": EditMode.POPOVER,\n                },\n                {\n                    \"name\": \"type\",\n                    \"display_name\": \"Type\",\n                    \"type\": \"str\",\n                    \"edit_mode\": EditMode.INLINE,\n                    \"description\": (\"Indicate the data type of the output field (e.g., str, int, float, bool, dict).\"),\n                    \"options\": [\"str\", \"int\", \"float\", \"bool\", \"dict\"],\n                    \"default\": \"str\",\n                },\n                {\n                    \"name\": \"multiple\",\n                    \"display_name\": \"As List\",\n                    \"type\": \"boolean\",\n                    \"description\": \"Set to True if this output field should be a list of the specified type.\",\n                    \"default\": \"False\",\n                    \"edit_mode\": EditMode.INLINE,\n                },\n            ],\n        ),\n        *LCToolsAgentComponent._base_inputs,\n        # removed memory inputs from agent component\n        # *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [\n        Output(name=\"response\", display_name=\"Response\", method=\"message_response\"),\n    ]\n\n    async def get_agent_requirements(self):\n        \"\"\"Get the agent requirements for the agent.\"\"\"\n        llm_model, display_name = await self.get_llm()\n        if llm_model is None:\n            msg = \"No language model selected. Please choose a model to proceed.\"\n            raise ValueError(msg)\n        self.model_name = get_model_name(llm_model, display_name=display_name)\n\n        # Get memory data\n        self.chat_history = await self.get_memory_data()\n        if isinstance(self.chat_history, Message):\n            self.chat_history = [self.chat_history]\n\n        # Add current date tool if enabled\n        if self.add_current_date_tool:\n            if not isinstance(self.tools, list):  # type: ignore[has-type]\n                self.tools = []\n            current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n            if not isinstance(current_date_tool, StructuredTool):\n                msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                raise TypeError(msg)\n            self.tools.append(current_date_tool)\n        return llm_model, self.chat_history, self.tools\n\n    async def message_response(self) -> Message:\n        try:\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            result = await self.run_agent(agent)\n\n            # Store result for potential JSON output\n            self._agent_result = result\n\n        except (ValueError, TypeError, KeyError) as e:\n            await logger.aerror(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            await logger.aerror(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        # Avoid catching blind Exception; let truly unexpected exceptions propagate\n        except Exception as e:\n            await logger.aerror(f\"Unexpected error: {e!s}\")\n            raise\n        else:\n            return result\n\n    def _preprocess_schema(self, schema):\n        \"\"\"Preprocess schema to ensure correct data types for build_model_from_schema.\"\"\"\n        processed_schema = []\n        for field in schema:\n            processed_field = {\n                \"name\": str(field.get(\"name\", \"field\")),\n                \"type\": str(field.get(\"type\", \"str\")),\n                \"description\": str(field.get(\"description\", \"\")),\n                \"multiple\": field.get(\"multiple\", False),\n            }\n            # Ensure multiple is handled correctly\n            if isinstance(processed_field[\"multiple\"], str):\n                processed_field[\"multiple\"] = processed_field[\"multiple\"].lower() in [\n                    \"true\",\n                    \"1\",\n                    \"t\",\n                    \"y\",\n                    \"yes\",\n                ]\n            processed_schema.append(processed_field)\n        return processed_schema\n\n    async def build_structured_output_base(self, content: str):\n        \"\"\"Build structured output with optional BaseModel validation.\"\"\"\n        json_pattern = r\"\\{.*\\}\"\n        schema_error_msg = \"Try setting an output schema\"\n\n        # Try to parse content as JSON first\n        json_data = None\n        try:\n            json_data = json.loads(content)\n        except json.JSONDecodeError:\n            json_match = re.search(json_pattern, content, re.DOTALL)\n            if json_match:\n                try:\n                    json_data = json.loads(json_match.group())\n                except json.JSONDecodeError:\n                    return {\"content\": content, \"error\": schema_error_msg}\n            else:\n                return {\"content\": content, \"error\": schema_error_msg}\n\n        # If no output schema provided, return parsed JSON without validation\n        if not hasattr(self, \"output_schema\") or not self.output_schema or len(self.output_schema) == 0:\n            return json_data\n\n        # Use BaseModel validation with schema\n        try:\n            processed_schema = self._preprocess_schema(self.output_schema)\n            output_model = build_model_from_schema(processed_schema)\n\n            # Validate against the schema\n            if isinstance(json_data, list):\n                # Multiple objects\n                validated_objects = []\n                for item in json_data:\n                    try:\n                        validated_obj = output_model.model_validate(item)\n                        validated_objects.append(validated_obj.model_dump())\n                    except ValidationError as e:\n                        await logger.aerror(f\"Validation error for item: {e}\")\n                        # Include invalid items with error info\n                        validated_objects.append({\"data\": item, \"validation_error\": str(e)})\n                return validated_objects\n\n            # Single object\n            try:\n                validated_obj = output_model.model_validate(json_data)\n                return [validated_obj.model_dump()]  # Return as list for consistency\n            except ValidationError as e:\n                await logger.aerror(f\"Validation error: {e}\")\n                return [{\"data\": json_data, \"validation_error\": str(e)}]\n\n        except (TypeError, ValueError) as e:\n            await logger.aerror(f\"Error building structured output: {e}\")\n            # Fallback to parsed JSON without validation\n            return json_data\n\n    async def json_response(self) -> Data:\n        \"\"\"Convert agent response to structured JSON Data output with schema validation.\"\"\"\n        # Always use structured chat agent for JSON response mode for better JSON formatting\n        try:\n            system_components = []\n\n            # 1. Agent Instructions (system_prompt)\n            agent_instructions = getattr(self, \"system_prompt\", \"\") or \"\"\n            if agent_instructions:\n                system_components.append(f\"{agent_instructions}\")\n\n            # 2. Format Instructions\n            format_instructions = getattr(self, \"format_instructions\", \"\") or \"\"\n            if format_instructions:\n                system_components.append(f\"Format instructions: {format_instructions}\")\n\n            # 3. Schema Information from BaseModel\n            if hasattr(self, \"output_schema\") and self.output_schema and len(self.output_schema) > 0:\n                try:\n                    processed_schema = self._preprocess_schema(self.output_schema)\n                    output_model = build_model_from_schema(processed_schema)\n                    schema_dict = output_model.model_json_schema()\n                    schema_info = (\n                        \"You are given some text that may include format instructions, \"\n                        \"explanations, or other content alongside a JSON schema.\\n\\n\"\n                        \"Your task:\\n\"\n                        \"- Extract only the JSON schema.\\n\"\n                        \"- Return it as valid JSON.\\n\"\n                        \"- Do not include format instructions, explanations, or extra text.\\n\\n\"\n                        \"Input:\\n\"\n                        f\"{json.dumps(schema_dict, indent=2)}\\n\\n\"\n                        \"Output (only JSON schema):\"\n                    )\n                    system_components.append(schema_info)\n                except (ValidationError, ValueError, TypeError, KeyError) as e:\n                    await logger.aerror(f\"Could not build schema for prompt: {e}\", exc_info=True)\n\n            # Combine all components\n            combined_instructions = \"\\n\\n\".join(system_components) if system_components else \"\"\n            llm_model, self.chat_history, self.tools = await self.get_agent_requirements()\n            self.set(\n                llm=llm_model,\n                tools=self.tools or [],\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=combined_instructions,\n            )\n\n            # Create and run structured chat agent\n            try:\n                structured_agent = self.create_agent_runnable()\n            except (NotImplementedError, ValueError, TypeError) as e:\n                await logger.aerror(f\"Error with structured chat agent: {e}\")\n                raise\n            try:\n                result = await self.run_agent(structured_agent)\n            except (\n                ExceptionWithMessageError,\n                ValueError,\n                TypeError,\n                RuntimeError,\n            ) as e:\n                await logger.aerror(f\"Error with structured agent result: {e}\")\n                raise\n            # Extract content from structured agent result\n            if hasattr(result, \"content\"):\n                content = result.content\n            elif hasattr(result, \"text\"):\n                content = result.text\n            else:\n                content = str(result)\n\n        except (\n            ExceptionWithMessageError,\n            ValueError,\n            TypeError,\n            NotImplementedError,\n            AttributeError,\n        ) as e:\n            await logger.aerror(f\"Error with structured chat agent: {e}\")\n            # Fallback to regular agent\n            content_str = \"No content returned from agent\"\n            return Data(data={\"content\": content_str, \"error\": str(e)})\n\n        # Process with structured output validation\n        try:\n            structured_output = await self.build_structured_output_base(content)\n\n            # Handle different output formats\n            if isinstance(structured_output, list) and structured_output:\n                if len(structured_output) == 1:\n                    return Data(data=structured_output[0])\n                return Data(data={\"results\": structured_output})\n            if isinstance(structured_output, dict):\n                return Data(data=structured_output)\n            return Data(data={\"content\": content})\n\n        except (ValueError, TypeError) as e:\n            await logger.aerror(f\"Error in structured output processing: {e}\")\n            return Data(data={\"content\": content, \"error\": str(e)})\n\n    async def get_memory_data(self):\n        # TODO: This is a temporary fix to avoid message duplication. We should develop a function for this.\n        messages = (\n            await MemoryComponent(**self.get_base_args())\n            .set(\n                session_id=self.graph.session_id,\n                order=\"Ascending\",\n                n_messages=self.n_messages,\n            )\n            .retrieve_messages()\n        )\n        return [\n            message for message in messages if getattr(message, \"id\", None) != getattr(self.input_value, \"id\", None)\n        ]\n\n    async def get_llm(self):\n        if not isinstance(self.agent_llm, str):\n            return self.agent_llm, None\n\n        try:\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if not provider_info:\n                msg = f\"Invalid model provider: {self.agent_llm}\"\n                raise ValueError(msg)\n\n            component_class = provider_info.get(\"component_class\")\n            display_name = component_class.display_name\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\", \"\")\n\n            return self._build_llm_model(component_class, inputs, prefix), display_name\n\n        except (AttributeError, ValueError, TypeError, RuntimeError) as e:\n            await logger.aerror(f\"Error building {self.agent_llm} language model: {e!s}\")\n            msg = f\"Failed to initialize language model: {e!s}\"\n            raise ValueError(msg) from e\n\n    def _build_llm_model(self, component, inputs, prefix=\"\"):\n        model_kwargs = {}\n        for input_ in inputs:\n            if hasattr(self, f\"{prefix}{input_.name}\"):\n                model_kwargs[input_.name] = getattr(self, f\"{prefix}{input_.name}\")\n        return component.set(**model_kwargs).build_model()\n\n    def set_component_params(self, component):\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n        if provider_info:\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\")\n            # Filter out json_mode and only use attributes that exist on this component\n            model_kwargs = {}\n            for input_ in inputs:\n                if hasattr(self, f\"{prefix}{input_.name}\"):\n                    model_kwargs[input_.name] = getattr(self, f\"{prefix}{input_.name}\")\n\n            return component.set(**model_kwargs)\n        return component\n\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\n        \"\"\"Delete specified fields from build_config.\"\"\"\n        for field in fields:\n            build_config.pop(field, None)\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\n    ) -> dotdict:\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        # Existing logic for updating build_config\n        if field_name in (\"agent_llm\",):\n            build_config[\"agent_llm\"][\"value\"] = field_value\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call the component class's update_build_config method\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\n                provider: (\n                    MODEL_PROVIDERS_DICT[provider][\"fields\"],\n                    [\n                        MODEL_PROVIDERS_DICT[other_provider][\"fields\"]\n                        for other_provider in MODEL_PROVIDERS_DICT\n                        if other_provider != provider\n                    ],\n                )\n                for provider in MODEL_PROVIDERS_DICT\n            }\n            if field_value in provider_configs:\n                fields_to_add, fields_to_delete = provider_configs[field_value]\n\n                # Delete fields from other providers\n                for fields in fields_to_delete:\n                    self.delete_fields(build_config, fields)\n\n                # Add provider-specific fields\n                if field_value == \"OpenAI\" and not any(field in build_config for field in fields_to_add):\n                    build_config.update(fields_to_add)\n                else:\n                    build_config.update(fields_to_add)\n                # Reset input types for agent_llm\n                build_config[\"agent_llm\"][\"input_types\"] = []\n                build_config[\"agent_llm\"][\"display_name\"] = \"Model Provider\"\n            elif field_value == \"connect_other_models\":\n                # Delete all provider fields\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\n                # # Update with custom component\n                custom_component = DropdownInput(\n                    name=\"agent_llm\",\n                    display_name=\"Language Model\",\n                    info=\"The provider of the language model that the agent will use to generate responses.\",\n                    options=[*MODEL_PROVIDERS_LIST],\n                    real_time_refresh=True,\n                    refresh_button=False,\n                    input_types=[\"LanguageModel\"],\n                    placeholder=\"Awaiting model input.\",\n                    options_metadata=[MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST],\n                    external_options={\n                        \"fields\": {\n                            \"data\": {\n                                \"node\": {\n                                    \"name\": \"connect_other_models\",\n                                    \"display_name\": \"Connect other models\",\n                                    \"icon\": \"CornerDownLeft\",\n                                },\n                            }\n                        },\n                    },\n                )\n                build_config.update({\"agent_llm\": custom_component.to_dict()})\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"agent_llm\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        if (\n            isinstance(self.agent_llm, str)\n            and self.agent_llm in MODEL_PROVIDERS_DICT\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\n        ):\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                component_class = self.set_component_params(component_class)\n                prefix = provider_info.get(\"prefix\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call each component class's update_build_config method\n                    # remove the prefix from the field_name\n                    if isinstance(field_name, str) and isinstance(prefix, str):\n                        field_name = field_name.replace(prefix, \"\")\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n\n    async def _get_tools(self) -> list[Tool]:\n        component_toolkit = _get_component_toolkit()\n        tools_names = self._build_tools_names()\n        agent_description = self.get_tool_description()\n        # TODO: Agent Description Depreciated Feature to be removed\n        description = f\"{agent_description}{tools_names}\"\n        tools = component_toolkit(component=self).get_tools(\n            tool_name=\"Call_Agent\",\n            tool_description=description,\n            callbacks=self.get_langchain_callbacks(),\n        )\n        if hasattr(self, \"tools_metadata\"):\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\n        return tools\n"
              },
              "format_instructions": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Output Format Instructions",
                "dynamic": false,
                "info": "Generic Template for structured output formatting. Valid only with Structured response.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "format_instructions",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are an AI that extracts structured JSON objects from unstructured text. Use a predefined schema with expected types (str, int, float, bool, dict). Extract ALL relevant instances that match the schema - if multiple patterns exist, capture them all. Fill missing or ambiguous values with defaults: null for missing values. Remove exact duplicates but keep variations that have different field values. Always return valid JSON in the expected format, never throw errors. If multiple objects can be extracted, return them all in the structured format."
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 158
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Chat History Messages",
                "dynamic": false,
                "info": "Number of chat history messages to retrieve.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 100
              },
              "output_schema": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Output Schema",
                "dynamic": false,
                "info": "Schema Validation: Define the structure and data types for structured output. No validation if no output schema.",
                "input_types": [],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "output_schema",
                "placeholder": "",
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "field",
                      "description": "Specify the name of the output field.",
                      "disable_edit": false,
                      "display_name": "Name",
                      "edit_mode": "inline",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "name",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "description of field",
                      "description": "Describe the purpose of the output field.",
                      "disable_edit": false,
                      "display_name": "Description",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "description",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "str",
                      "description": "Indicate the data type of the output field (e.g., str, int, float, bool, dict).",
                      "disable_edit": false,
                      "display_name": "Type",
                      "edit_mode": "inline",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "type",
                      "options": [
                        "str",
                        "int",
                        "float",
                        "bool",
                        "dict"
                      ],
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": false,
                      "description": "Set to True if this output field should be a list of the specified type.",
                      "disable_edit": false,
                      "display_name": "As List",
                      "edit_mode": "inline",
                      "filterable": true,
                      "formatter": "boolean",
                      "hidden": false,
                      "name": "multiple",
                      "sortable": true,
                      "type": "boolean"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": []
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are a helpful assistant that can use tools to answer questions and perform tasks.\n\n  1. Always RESEARCH using the Playwright Workflow tool\n  1.5. Always CREATE the file using FileSystemTool (operation='write')\n  2. Always use shell commands to create files and interact with the filesystem.\n  3. Always INSTALL dependencies using CodeRunnerTool\n  4. Always ATTEMPT to run the code using CodeRunnerTool\n  5. Always Report actual errors encountered, don't assume failure in advance\n\nWhen sharing information always use the playwright tool to search for citable sources. Do not ever rely solely on the knowledge you already possess. \n\nAlways Be cognizant of tool use history and observe any pattern usage that could indicate a loop. If a loop is indicated, plan an action that exits pattern while continuing progress.\n  "
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Agent"
        },
        "dragging": false,
        "id": "Agent-zrOq9",
        "measured": {
          "height": 427,
          "width": 320
        },
        "position": {
          "x": 2531.5527050239903,
          "y": -607.0877349945486
        },
        "selected": true,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-HzERS",
          "node": {
            "base_classes": [
              "Data",
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Tool that allows agents to interact with the filesystem - read, write, append, list files and directories",
            "display_name": "FileSystem Tool",
            "documentation": "https://docs.langflow.org/components-tools",
            "edited": true,
            "field_order": [
              "default_operation",
              "default_path",
              "default_content",
              "safe_mode",
              "create_parents"
            ],
            "frozen": false,
            "icon": "folder-open",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Data",
                "group_outputs": false,
                "hidden": null,
                "method": "run_model",
                "name": "api_run_model",
                "options": null,
                "required_inputs": null,
                "tool_mode": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__"
              },
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tool",
                "group_outputs": false,
                "hidden": null,
                "method": "build_tool",
                "name": "api_build_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"\nFileSystem Tool Component for Langflow\n=======================================\nThis is a Tool component that enables agents to interact with the filesystem.\nAgents can use this tool to read, write, append, list, and manage files/directories.\n\nAuthor: Claude\nVersion: 2.0.0 (Tool version)\n\"\"\"\n\nimport json\nimport os\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Union\n\nfrom langchain.agents import Tool\nfrom langchain_core.tools import StructuredTool\nfrom pydantic import BaseModel, Field\n\nfrom langflow.base.langchain_utilities.model import LCToolComponent\nfrom langflow.inputs import (\n    BoolInput,\n    DropdownInput,\n    MessageTextInput,\n    MultilineInput,\n)\nfrom langflow.io import Output\nfrom langflow.schema.data import Data\n\n\nclass FileSystemToolSchema(BaseModel):\n    \"\"\"Schema for FileSystem Tool inputs\"\"\"\n    operation: str = Field(\n        description=\"The operation to perform: read, write, append, list, exists, create_directory, or delete_file\"\n    )\n    path: str = Field(\n        description=\"The file or directory path\"\n    )\n    content: str = Field(\n        default=\"\",\n        description=\"Content to write or append (only for write/append operations)\"\n    )\n\n\nclass FileSystemTool(LCToolComponent):\n    \"\"\"\n    A comprehensive filesystem tool for agent interactions.\n    Provides safe file operations with clear feedback.\n    \"\"\"\n\n    display_name = \"FileSystem Tool\"\n    description = \"Tool that allows agents to interact with the filesystem - read, write, append, list files and directories\"\n    documentation = \"https://docs.langflow.org/components-tools\"\n    icon = \"folder-open\"\n    name = \"FileSystemTool\"\n\n    inputs = [\n        DropdownInput(\n            name=\"default_operation\",\n            display_name=\"Default Operation\",\n            options=[\n                \"read\",\n                \"write\",\n                \"append\",\n                \"list\",\n                \"exists\",\n                \"create_directory\",\n                \"delete_file\"\n            ],\n            value=\"read\",\n            info=\"Default operation when used directly (not by agent)\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"default_path\",\n            display_name=\"Default Path\",\n            info=\"Default path when used directly (not by agent)\",\n            value=\"\",\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"default_content\",\n            display_name=\"Default Content\",\n            info=\"Default content for write/append when used directly\",\n            value=\"\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"safe_mode\",\n            display_name=\"Safe Mode\",\n            value=True,\n            info=\"If true, restricts operations to working directory and safe locations\",\n        ),\n        BoolInput(\n            name=\"create_parents\",\n            display_name=\"Create Parent Directories\",\n            value=True,\n            info=\"If true, creates parent directories if they don't exist (for write operations)\",\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(name=\"api_run_model\", display_name=\"Data\", method=\"run_model\"),\n        Output(name=\"api_build_tool\", display_name=\"Tool\", method=\"build_tool\"),\n    ]\n\n    def run_model(self) -> List[Data]:\n        \"\"\"Direct execution of the tool (when not used by agent)\"\"\"\n        result = self._execute_operation(\n            self.default_operation,\n            self.default_path,\n            self.default_content\n        )\n\n        # Convert result to Data object\n        data = Data(\n            text=result,\n            data={\"operation\": self.default_operation, \"path\": self.default_path, \"result\": result}\n        )\n\n        self.status = result\n        return [data]\n\n    def build_tool(self) -> Tool:\n        \"\"\"Build the tool for agent use\"\"\"\n\n        def filesystem_function(operation: str, path: str, content: str = \"\") -> str:\n            \"\"\"\n            Execute filesystem operations.\n\n            Args:\n                operation: The operation to perform (read, write, append, list, exists, create_directory, delete_file)\n                path: The file or directory path\n                content: Content for write/append operations (optional)\n\n            Returns:\n                String result of the operation\n            \"\"\"\n            return self._execute_operation(operation, path, content)\n\n        # Create a StructuredTool with schema\n        tool = StructuredTool.from_function(\n            func=filesystem_function,\n            name=\"FileSystem\",\n            description=(\n                \"Interact with the filesystem. Operations: \"\n                \"read (get file contents), \"\n                \"write (create/overwrite file), \"\n                \"append (add to file), \"\n                \"list (show directory contents), \"\n                \"exists (check if path exists), \"\n                \"create_directory (make new folder), \"\n                \"delete_file (remove file). \"\n                \"Example: operation='read', path='config.json'\"\n            ),\n            args_schema=FileSystemToolSchema,\n            return_direct=False,\n        )\n\n        return tool\n\n    def _execute_operation(self, operation: str, path_str: str, content: str = \"\") -> str:\n        \"\"\"Execute the filesystem operation\"\"\"\n        try:\n            if not path_str:\n                return \"Error: Path is required\"\n\n            path = self._resolve_path(path_str)\n\n            # Execute the appropriate operation\n            if operation == \"read\":\n                return self._read_file(path)\n            elif operation == \"write\":\n                return self._write_file(path, content)\n            elif operation == \"append\":\n                return self._append_file(path, content)\n            elif operation == \"list\":\n                return self._list_directory(path)\n            elif operation == \"exists\":\n                return self._check_exists(path)\n            elif operation == \"create_directory\":\n                return self._create_directory(path)\n            elif operation == \"delete_file\":\n                return self._delete_file(path)\n            else:\n                return f\"Error: Unknown operation '{operation}'. Use: read, write, append, list, exists, create_directory, delete_file\"\n\n        except Exception as e:\n            return f\"FileSystem Error ({operation}): {str(e)}\"\n\n    def _resolve_path(self, path_str: str) -> Path:\n        \"\"\"Resolve and validate the path\"\"\"\n        path = Path(path_str).expanduser()\n\n        # If not absolute, make it relative to current working directory\n        if not path.is_absolute():\n            path = Path.cwd() / path\n\n        # Safety check if safe_mode is enabled\n        if self.safe_mode:\n            try:\n                resolved = path.resolve()\n                cwd = Path.cwd().resolve()\n\n                # Allow operations within current working directory and temp directories\n                safe_dirs = [\n                    cwd,\n                    Path('/tmp'),\n                    Path('/var/tmp'),\n                    Path.home() / 'Documents',\n                    Path.home() / 'Desktop',\n                    Path.home() / 'Downloads',\n                ]\n\n                # For Windows, add Windows temp directory\n                if os.name == 'nt':\n                    safe_dirs.extend([\n                        Path(os.environ.get('TEMP', '')),\n                        Path(os.environ.get('TMP', '')),\n                    ])\n\n                is_safe = False\n                for safe_dir in safe_dirs:\n                    try:\n                        if safe_dir.exists() and (resolved.is_relative_to(safe_dir) or resolved == safe_dir):\n                            is_safe = True\n                            break\n                    except (ValueError, RuntimeError):\n                        continue\n\n                if not is_safe and operation != \"read\":\n                    raise ValueError(\n                        f\"Safe mode: Write operations outside safe directories not allowed. \"\n                        f\"Path: {resolved}. Safe directories include working directory, Desktop, Documents, Downloads, and temp folders.\"\n                    )\n\n            except (RuntimeError, ValueError) as e:\n                if \"not allowed\" in str(e):\n                    raise\n                # Path doesn't exist yet, check parent for write operations\n                if operation in [\"write\", \"create_directory\"]:\n                    parent = path.parent.resolve()\n                    if not any(parent.is_relative_to(d) for d in [cwd, Path.home()]):\n                        raise ValueError(f\"Safe mode: Parent directory outside safe locations\")\n\n        return path\n\n    def _read_file(self, path: Path) -> str:\n        \"\"\"Read file contents\"\"\"\n        if not path.exists():\n            return f\"Error: File not found: {path}\"\n\n        if not path.is_file():\n            return f\"Error: Path is not a file: {path}\"\n\n        try:\n            with open(path, 'r', encoding='utf-8') as f:\n                content = f.read()\n\n            # Truncate very long files\n            if len(content) > 10000:\n                content = content[:10000] + f\"\\n... (truncated, showing first 10000 of {len(content)} chars)\"\n\n            return f\"File contents of {path}:\\n{content}\"\n        except UnicodeDecodeError:\n            return f\"Error: File appears to be binary and cannot be read as text: {path}\"\n\n    def _write_file(self, path: Path, content: str) -> str:\n        \"\"\"Write content to file\"\"\"\n        if not content:\n            return \"Error: Content cannot be empty for write operation\"\n\n        # Create parent directories if requested\n        if self.create_parents and not path.parent.exists():\n            path.parent.mkdir(parents=True, exist_ok=True)\n\n        existed = path.exists()\n\n        with open(path, 'w', encoding='utf-8') as f:\n            f.write(content)\n\n        action = \"Overwrote\" if existed else \"Created\"\n        return f\"{action} file: {path} ({len(content)} characters written)\"\n\n    def _append_file(self, path: Path, content: str) -> str:\n        \"\"\"Append content to file\"\"\"\n        if not content:\n            return \"Error: Content cannot be empty for append operation\"\n\n        if not path.exists():\n            return f\"Error: File not found (use 'write' to create): {path}\"\n\n        if not path.is_file():\n            return f\"Error: Path is not a file: {path}\"\n\n        with open(path, 'a', encoding='utf-8') as f:\n            f.write(content)\n\n        return f\"Appended {len(content)} characters to: {path}\"\n\n    def _list_directory(self, path: Path) -> str:\n        \"\"\"List directory contents\"\"\"\n        if not path.exists():\n            return f\"Error: Directory not found: {path}\"\n\n        if not path.is_dir():\n            return f\"Error: Path is not a directory: {path}\"\n\n        items = []\n        for item in sorted(path.iterdir()):\n            if item.is_dir():\n                items.append(f\"[DIR]  {item.name}\")\n            else:\n                size = item.stat().st_size\n                if size < 1024:\n                    size_str = f\"{size}B\"\n                elif size < 1024 * 1024:\n                    size_str = f\"{size/1024:.1f}KB\"\n                else:\n                    size_str = f\"{size/(1024*1024):.1f}MB\"\n                items.append(f\"[FILE] {item.name} ({size_str})\")\n\n        if not items:\n            return f\"Directory is empty: {path}\"\n\n        return f\"Contents of {path}:\\n\" + \"\\n\".join(items)\n\n    def _check_exists(self, path: Path) -> str:\n        \"\"\"Check if path exists\"\"\"\n        if path.exists():\n            if path.is_file():\n                size = path.stat().st_size\n                return f\"EXISTS: File at {path} (size: {size} bytes)\"\n            elif path.is_dir():\n                count = len(list(path.iterdir()))\n                return f\"EXISTS: Directory at {path} (contains {count} items)\"\n            else:\n                return f\"EXISTS: Special file at {path}\"\n        else:\n            return f\"NOT FOUND: {path} does not exist\"\n\n    def _create_directory(self, path: Path) -> str:\n        \"\"\"Create a directory\"\"\"\n        if path.exists():\n            if path.is_dir():\n                return f\"Directory already exists: {path}\"\n            else:\n                return f\"Error: Path exists but is not a directory: {path}\"\n\n        path.mkdir(parents=self.create_parents, exist_ok=True)\n        return f\"Created directory: {path}\"\n\n    def _delete_file(self, path: Path) -> str:\n        \"\"\"Delete a file (not directories for safety)\"\"\"\n        if not path.exists():\n            return f\"Error: File not found: {path}\"\n\n        if not path.is_file():\n            return f\"Error: Can only delete files, not directories: {path}\"\n\n        size = path.stat().st_size\n        path.unlink()\n        return f\"Deleted file: {path} (was {size} bytes)\""
              },
              "create_parents": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Create Parent Directories",
                "dynamic": false,
                "info": "If true, creates parent directories if they don't exist (for write operations)",
                "list": false,
                "list_add_label": "Add More",
                "name": "create_parents",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "default_content": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Default Content",
                "dynamic": false,
                "info": "Default content for write/append when used directly",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "default_content",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "default_operation": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Default Operation",
                "dynamic": false,
                "external_options": {},
                "info": "Default operation when used directly (not by agent)",
                "name": "default_operation",
                "options": [
                  "read",
                  "write",
                  "append",
                  "list",
                  "exists",
                  "create_directory",
                  "delete_file"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "read"
              },
              "default_path": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Default Path",
                "dynamic": false,
                "info": "Default path when used directly (not by agent)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "default_path",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "safe_mode": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Safe Mode",
                "dynamic": false,
                "info": "If true, restricts operations to working directory and safe locations",
                "list": false,
                "list_add_label": "Add More",
                "name": "safe_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              }
            },
            "tool_mode": false
          },
          "selected_output": "api_build_tool",
          "showNode": true,
          "type": "FileSystemTool"
        },
        "dragging": false,
        "id": "CustomComponent-HzERS",
        "measured": {
          "height": 179,
          "width": 320
        },
        "position": {
          "x": 2131.329153986343,
          "y": -182.09957991384886
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-RBhOR",
          "node": {
            "base_classes": [
              "Data"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Executes shell commands, runs code in multiple languages, installs packages, and performs git operations with comprehensive security controls and verbose output.",
            "display_name": "Code Runner Tool",
            "documentation": "https://docs.langflow.org/components-custom",
            "edited": true,
            "field_order": [
              "command",
              "execution_mode",
              "package_manager",
              "working_directory",
              "environment_vars",
              "timeout",
              "security_mode",
              "allowed_commands",
              "blocked_commands",
              "output_format",
              "auto_install_packages",
              "verbose",
              "capture_realtime"
            ],
            "frozen": false,
            "icon": "terminal",
            "last_updated": "2025-11-04T01:44:11.094Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "allowed_commands": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Allowed Commands",
                "dynamic": false,
                "info": "Whitelist of allowed command patterns (one per line, used in Restricted mode)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "allowed_commands",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "auto_install_packages": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Auto-install Packages",
                "dynamic": false,
                "info": "Automatically install missing packages when detected",
                "list": false,
                "list_add_label": "Add More",
                "name": "auto_install_packages",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "blocked_commands": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Blocked Commands",
                "dynamic": false,
                "info": "Blacklist of forbidden command patterns (one per line, used in Safe mode)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "blocked_commands",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "rm -rf /\nformat\nmkfs\ndd if=/dev/zero\n:(){ :|:& };:"
              },
              "capture_realtime": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Real-time Output",
                "dynamic": false,
                "info": "Stream output as it's generated (for long-running commands)",
                "list": false,
                "list_add_label": "Add More",
                "name": "capture_realtime",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"\r\nCode Runner Tool Component for Langflow\r\n========================================\r\nA comprehensive shell command executor and code runner for Langflow agents.\r\nSupports shell commands, Python, Node.js, Git operations, and package management\r\nwith enhanced security controls and verbose output capabilities.\r\n\r\nAuthor: Claude\r\nVersion: 2.0.0\r\n\"\"\"\r\n\r\nimport subprocess\r\nimport sys\r\nimport json\r\nimport tempfile\r\nimport os\r\nfrom pathlib import Path\r\nfrom typing import Dict, List, Optional, Any\r\nimport time\r\nimport re\r\nimport shlex\r\nimport platform\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.io import (\r\n    DropdownInput,\r\n    MultilineInput,\r\n    MessageTextInput,\r\n    BoolInput,\r\n    IntInput,\r\n    Output,\r\n)\r\nfrom langflow.schema import Data\r\n\r\n\r\nclass CodeRunnerTool(Component):\r\n    \"\"\"\r\n    Advanced shell command executor and code runner for Langflow agents.\r\n    Supports shell commands, Python, Node.js, Git operations, and package management.\r\n    \"\"\"\r\n\r\n    display_name = \"Code Runner Tool\"\r\n    description = (\r\n        \"Executes shell commands, runs code in multiple languages, installs packages, \"\r\n        \"and performs git operations with comprehensive security controls and verbose output.\"\r\n    )\r\n    documentation = \"https://docs.langflow.org/components-custom\"\r\n    icon = \"terminal\"\r\n    name = \"CodeRunnerTool\"\r\n\r\n    # Tool capabilities description for agents\r\n    tool_description = \"\"\"\r\n    This tool can:\r\n    - Execute any shell/bash command (ls, pwd, cat, grep, etc.)\r\n    - Run Python code and scripts (with automatic package installation)\r\n    - Execute Node.js/JavaScript code\r\n    - Perform Git operations (clone, pull, push, commit, etc.)\r\n    - Install packages via pip, npm, yarn, apt-get, brew\r\n    - Create and manage files and directories\r\n    - Set environment variables\r\n    - Execute with timeout controls\r\n    - Provide detailed execution feedback and error messages\r\n    \"\"\"\r\n\r\n    inputs = [\r\n        MessageTextInput(\r\n            name=\"command\",\r\n            display_name=\"Command/Code\",\r\n            info=\"Shell command or code to execute. Supports multi-line input for scripts.\",\r\n            tool_mode=True,  # Enable as agent tool\r\n            value=\"\"\r\n        ),\r\n        DropdownInput(\r\n            name=\"execution_mode\",\r\n            display_name=\"Execution Mode\",\r\n            info=\"How to interpret and execute the command\",\r\n            options=[\r\n                \"Auto-detect\",\r\n                \"Shell\",\r\n                \"Python\",\r\n                \"Node.js\",\r\n                \"Package Install\",\r\n                \"Git\"\r\n            ],\r\n            value=\"Auto-detect\"\r\n        ),\r\n        DropdownInput(\r\n            name=\"package_manager\",\r\n            display_name=\"Package Manager\",\r\n            info=\"Package manager to use for installations\",\r\n            options=[\r\n                \"Auto-detect\",\r\n                \"pip\",\r\n                \"pip3\",\r\n                \"npm\",\r\n                \"yarn\",\r\n                \"apt-get\",\r\n                \"apt\",\r\n                \"brew\",\r\n                \"dnf\",\r\n                \"yum\"\r\n            ],\r\n            value=\"Auto-detect\",\r\n            advanced=True\r\n        ),\r\n        MessageTextInput(\r\n            name=\"working_directory\",\r\n            display_name=\"Working Directory\",\r\n            info=\"Directory to execute the command in (defaults to current directory)\",\r\n            value=\"\",\r\n            advanced=True\r\n        ),\r\n        MultilineInput(\r\n            name=\"environment_vars\",\r\n            display_name=\"Environment Variables\",\r\n            info=\"Additional environment variables (KEY=VALUE format, one per line)\",\r\n            value=\"\",\r\n            advanced=True\r\n        ),\r\n        IntInput(\r\n            name=\"timeout\",\r\n            display_name=\"Timeout (seconds)\",\r\n            info=\"Maximum execution time in seconds (0 = no timeout)\",\r\n            value=30,\r\n            advanced=True\r\n        ),\r\n        DropdownInput(\r\n            name=\"security_mode\",\r\n            display_name=\"Security Mode\",\r\n            info=\"Security level for command execution\",\r\n            options=[\r\n                \"Safe (Recommended)\",\r\n                \"Unrestricted\",\r\n                \"Restricted\",\r\n                \"Read-only\"\r\n            ],\r\n            value=\"Safe (Recommended)\"\r\n        ),\r\n        MultilineInput(\r\n            name=\"allowed_commands\",\r\n            display_name=\"Allowed Commands\",\r\n            info=\"Whitelist of allowed command patterns (one per line, used in Restricted mode)\",\r\n            value=\"\",\r\n            advanced=True\r\n        ),\r\n        MultilineInput(\r\n            name=\"blocked_commands\",\r\n            display_name=\"Blocked Commands\",\r\n            info=\"Blacklist of forbidden command patterns (one per line, used in Safe mode)\",\r\n            value=\"rm -rf /\\nformat\\nmkfs\\ndd if=/dev/zero\\n:(){ :|:& };:\",\r\n            advanced=True\r\n        ),\r\n        DropdownInput(\r\n            name=\"output_format\",\r\n            display_name=\"Output Format\",\r\n            info=\"How to format the execution output\",\r\n            options=[\r\n                \"Full\",\r\n                \"Stdout only\",\r\n                \"Stderr only\",\r\n                \"Summary\",\r\n                \"JSON\"\r\n            ],\r\n            value=\"Full\"\r\n        ),\r\n        BoolInput(\r\n            name=\"auto_install_packages\",\r\n            display_name=\"Auto-install Packages\",\r\n            info=\"Automatically install missing packages when detected\",\r\n            value=False,\r\n            advanced=True\r\n        ),\r\n        BoolInput(\r\n            name=\"verbose\",\r\n            display_name=\"Verbose Output\",\r\n            info=\"Include detailed execution information and metrics\",\r\n            value=True\r\n        ),\r\n        BoolInput(\r\n            name=\"capture_realtime\",\r\n            display_name=\"Real-time Output\",\r\n            info=\"Stream output as it's generated (for long-running commands)\",\r\n            value=False,\r\n            advanced=True\r\n        )\r\n    ]\r\n\r\n    outputs = [\r\n        Output(\r\n            name=\"result\",\r\n            display_name=\"Execution Result\",\r\n            method=\"execute_command\"\r\n        )\r\n    ]\r\n\r\n    def build_config(self):\r\n        \"\"\"Dynamic configuration based on selected options.\"\"\"\r\n        config = super().build_config()\r\n\r\n        # Show/hide fields based on execution mode\r\n        if hasattr(self, 'execution_mode'):\r\n            if self.execution_mode == \"Package Install\":\r\n                config[\"package_manager\"][\"show\"] = True\r\n                config[\"auto_install_packages\"][\"show\"] = False\r\n            elif self.execution_mode in [\"Python\", \"Node.js\"]:\r\n                config[\"auto_install_packages\"][\"show\"] = True\r\n                config[\"package_manager\"][\"show\"] = False\r\n            else:\r\n                config[\"package_manager\"][\"show\"] = False\r\n                config[\"auto_install_packages\"][\"show\"] = False\r\n\r\n        # Show/hide security fields\r\n        if hasattr(self, 'security_mode'):\r\n            if self.security_mode == \"Restricted\":\r\n                config[\"allowed_commands\"][\"show\"] = True\r\n                config[\"blocked_commands\"][\"show\"] = False\r\n            elif self.security_mode == \"Safe (Recommended)\":\r\n                config[\"blocked_commands\"][\"show\"] = True\r\n                config[\"allowed_commands\"][\"show\"] = False\r\n            else:\r\n                config[\"allowed_commands\"][\"show\"] = False\r\n                config[\"blocked_commands\"][\"show\"] = False\r\n\r\n        return config\r\n\r\n    def execute_command(self) -> Data:\r\n        \"\"\"Execute the command with comprehensive error handling and output formatting.\"\"\"\r\n        start_time = time.time()\r\n\r\n        # Initialize result structure\r\n        result = {\r\n            \"success\": False,\r\n            \"command\": str(self.command).strip(),\r\n            \"mode\": self.execution_mode,\r\n            \"stdout\": \"\",\r\n            \"stderr\": \"\",\r\n            \"exit_code\": -1,\r\n            \"execution_time\": 0,\r\n            \"working_directory\": \"\",\r\n            \"environment\": {},\r\n            \"packages_installed\": [],\r\n            \"warnings\": [],\r\n            \"suggestions\": [],\r\n            \"error\": None\r\n        }\r\n\r\n        try:\r\n            # Validate and prepare command\r\n            command = self._prepare_command(result)\r\n            if not command:\r\n                return Data(data=result)\r\n\r\n            # Check security restrictions\r\n            if not self._check_security(command, result):\r\n                return Data(data=result)\r\n\r\n            # Detect and set execution mode\r\n            actual_mode = self._detect_execution_mode(command)\r\n            if self.execution_mode == \"Auto-detect\":\r\n                result[\"mode\"] = actual_mode\r\n\r\n            # Prepare environment\r\n            env = self._prepare_environment()\r\n            result[\"environment\"] = {k: v for k, v in env.items() if k not in os.environ}\r\n\r\n            # Set working directory\r\n            working_dir = self._get_working_directory()\r\n            result[\"working_directory\"] = str(working_dir)\r\n\r\n            # Execute based on mode\r\n            if result[\"mode\"] == \"Package Install\" or (\r\n                self.execution_mode == \"Package Install\"\r\n            ):\r\n                self._execute_package_install(command, result, env)\r\n            elif result[\"mode\"] == \"Python\" or (\r\n                self.execution_mode == \"Python\"\r\n            ):\r\n                self._execute_python(command, result, env, working_dir)\r\n            elif result[\"mode\"] == \"Node.js\" or (\r\n                self.execution_mode == \"Node.js\"\r\n            ):\r\n                self._execute_nodejs(command, result, env, working_dir)\r\n            elif result[\"mode\"] == \"Git\" or (\r\n                self.execution_mode == \"Git\"\r\n            ):\r\n                self._execute_git(command, result, env, working_dir)\r\n            else:\r\n                # Default shell execution\r\n                self._execute_shell(command, result, env, working_dir)\r\n\r\n        except Exception as e:\r\n            result[\"success\"] = False\r\n            result[\"error\"] = str(e)\r\n            result[\"stderr\"] = f\"Execution error: {str(e)}\"\r\n            result[\"suggestions\"].append(\r\n                \"Check command syntax and ensure required tools are installed\"\r\n            )\r\n\r\n        finally:\r\n            result[\"execution_time\"] = round(time.time() - start_time, 3)\r\n\r\n            # Format output based on selection\r\n            formatted_result = self._format_output(result)\r\n\r\n            # Update component status\r\n            if result[\"success\"]:\r\n                self.status = f\"✓ Command executed successfully in {result['execution_time']}s\"\r\n            else:\r\n                self.status = f\"✗ Command failed: {result.get('error', 'Unknown error')}\"\r\n\r\n            return Data(data=formatted_result)\r\n\r\n    def _prepare_command(self, result: Dict) -> Optional[str]:\r\n        \"\"\"Prepare and validate the command.\"\"\"\r\n        command = str(self.command).strip()\r\n\r\n        if not command:\r\n            result[\"error\"] = \"No command provided\"\r\n            result[\"suggestions\"].append(\"Please provide a command to execute\")\r\n            return None\r\n\r\n        # Add command history tracking\r\n        if self.verbose:\r\n            result[\"warnings\"].append(f\"Executing: {command[:100]}...\" if len(command) > 100 else f\"Executing: {command}\")\r\n\r\n        return command\r\n\r\n    def _check_security(self, command: str, result: Dict) -> bool:\r\n        \"\"\"Check security restrictions based on mode.\"\"\"\r\n        mode = self.security_mode\r\n\r\n        if mode == \"Read-only\":\r\n            # Only allow read operations\r\n            write_patterns = [\r\n                'write', 'rm', 'del', 'delete', 'mv', 'move', 'cp', 'copy',\r\n                'mkdir', 'touch', 'chmod', 'chown', '>', '>>', 'tee',\r\n                'install', 'uninstall', 'update', 'upgrade'\r\n            ]\r\n            if any(pattern in command.lower() for pattern in write_patterns):\r\n                result[\"error\"] = \"Write operations not allowed in Read-only mode\"\r\n                result[\"suggestions\"].append(\"Switch to a different security mode to perform write operations\")\r\n                return False\r\n\r\n        elif mode == \"Restricted\":\r\n            # Check against whitelist\r\n            allowed = [line.strip() for line in str(self.allowed_commands or \"\").splitlines() if line.strip()]\r\n            if not allowed:\r\n                result[\"error\"] = \"No allowed commands defined in Restricted mode\"\r\n                result[\"suggestions\"].append(\"Add allowed command patterns or switch security mode\")\r\n                return False\r\n\r\n            if not any(re.search(pattern, command) for pattern in allowed):\r\n                result[\"error\"] = f\"Command not in allowed list for Restricted mode\"\r\n                result[\"suggestions\"].append(f\"Allowed patterns: {', '.join(allowed[:5])}\")\r\n                return False\r\n\r\n        elif mode == \"Safe (Recommended)\":\r\n            # Check against blacklist\r\n            blocked = [line.strip() for line in str(self.blocked_commands or \"\").splitlines() if line.strip()]\r\n            for pattern in blocked:\r\n                if pattern in command:\r\n                    result[\"error\"] = f\"Command contains blocked pattern: {pattern}\"\r\n                    result[\"warnings\"].append(\"This command is potentially dangerous\")\r\n                    result[\"suggestions\"].append(\"Review the command for safety or switch to Unrestricted mode\")\r\n                    return False\r\n\r\n        # Check for additional dangerous patterns in Safe mode\r\n        if mode == \"Safe (Recommended)\":\r\n            dangerous_patterns = [\r\n                (r'rm\\s+-rf\\s+/', \"Attempting to delete root directory\"),\r\n                (r':(){ :|:& };:', \"Fork bomb detected\"),\r\n                (r'dd\\s+if=/dev/(zero|random)', \"Potentially destructive disk operation\"),\r\n                (r'mkfs', \"Filesystem format command detected\"),\r\n                (r'format\\s+[cC]:', \"Windows format command detected\")\r\n            ]\r\n\r\n            for pattern, warning in dangerous_patterns:\r\n                if re.search(pattern, command):\r\n                    result[\"error\"] = warning\r\n                    result[\"warnings\"].append(\"This operation could damage your system\")\r\n                    return False\r\n\r\n        return True\r\n\r\n    def _detect_execution_mode(self, command: str) -> str:\r\n        \"\"\"Auto-detect the execution mode from command.\"\"\"\r\n        command_lower = command.lower()\r\n\r\n        # Check for package installation commands\r\n        package_managers = ['pip', 'npm', 'yarn', 'apt-get', 'apt', 'brew', 'dnf', 'yum']\r\n        for pm in package_managers:\r\n            if command_lower.startswith(pm + ' install') or command_lower.startswith(pm + ' add'):\r\n                return \"Package Install\"\r\n\r\n        # Check for git commands\r\n        if command_lower.startswith('git '):\r\n            return \"Git\"\r\n\r\n        # Check for Python\r\n        if command_lower.startswith('python') or command_lower.startswith('py '):\r\n            return \"Python\"\r\n\r\n        # Check for Node.js\r\n        if command_lower.startswith('node ') or command_lower.startswith('npm ') or command_lower.startswith('yarn '):\r\n            return \"Node.js\"\r\n\r\n        # Check for inline Python code\r\n        if 'import ' in command or 'def ' in command or 'print(' in command:\r\n            return \"Python\"\r\n\r\n        # Check for inline JavaScript code\r\n        if 'const ' in command or 'let ' in command or 'console.log' in command or 'require(' in command:\r\n            return \"Node.js\"\r\n\r\n        return \"Shell\"\r\n\r\n    def _prepare_environment(self) -> Dict[str, str]:\r\n        \"\"\"Prepare environment variables.\"\"\"\r\n        env = os.environ.copy()\r\n\r\n        # Add custom environment variables\r\n        if self.environment_vars:\r\n            for line in str(self.environment_vars).splitlines():\r\n                line = line.strip()\r\n                if '=' in line:\r\n                    key, value = line.split('=', 1)\r\n                    env[key.strip()] = value.strip()\r\n\r\n        # Add tool-specific environment variables\r\n        env['LANGFLOW_TOOL'] = 'CodeRunnerTool'\r\n        env['PYTHONUNBUFFERED'] = '1'  # For real-time Python output\r\n\r\n        return env\r\n\r\n    def _get_working_directory(self) -> Path:\r\n        \"\"\"Get and validate working directory.\"\"\"\r\n        if self.working_directory:\r\n            work_dir = Path(self.working_directory).expanduser()\r\n            if not work_dir.exists():\r\n                work_dir.mkdir(parents=True, exist_ok=True)\r\n            return work_dir\r\n        return Path.cwd()\r\n\r\n    def _execute_shell(self, command: str, result: Dict, env: Dict, working_dir: Path):\r\n        \"\"\"Execute shell command.\"\"\"\r\n        try:\r\n            # Prepare shell command\r\n            if platform.system() == \"Windows\":\r\n                shell_cmd = command\r\n                shell = True\r\n            else:\r\n                shell_cmd = command\r\n                shell = True\r\n\r\n            # Execute with timeout\r\n            process = subprocess.run(\r\n                shell_cmd,\r\n                shell=shell,\r\n                capture_output=True,\r\n                text=True,\r\n                timeout=self.timeout if self.timeout > 0 else None,\r\n                env=env,\r\n                cwd=str(working_dir)\r\n            )\r\n\r\n            result[\"stdout\"] = process.stdout\r\n            result[\"stderr\"] = process.stderr\r\n            result[\"exit_code\"] = process.returncode\r\n            result[\"success\"] = (process.returncode == 0)\r\n\r\n            # Add suggestions for common errors\r\n            if process.returncode != 0:\r\n                self._add_error_suggestions(command, process.stderr, result)\r\n\r\n        except subprocess.TimeoutExpired:\r\n            result[\"error\"] = f\"Command timed out after {self.timeout} seconds\"\r\n            result[\"suggestions\"].append(\"Increase timeout or optimize the command\")\r\n        except Exception as e:\r\n            result[\"error\"] = str(e)\r\n            result[\"stderr\"] = str(e)\r\n\r\n    def _execute_python(self, command: str, result: Dict, env: Dict, working_dir: Path):\r\n        \"\"\"Execute Python code or script.\"\"\"\r\n        # Check if it's a file execution or inline code\r\n        if command.startswith('python ') or command.startswith('python3 '):\r\n            # File execution\r\n            self._execute_shell(command, result, env, working_dir)\r\n        else:\r\n            # Inline code execution\r\n            try:\r\n                # Check for missing packages\r\n                if self.auto_install_packages:\r\n                    missing_packages = self._detect_missing_python_packages(command)\r\n                    if missing_packages:\r\n                        result[\"warnings\"].append(f\"Installing missing packages: {', '.join(missing_packages)}\")\r\n                        for package in missing_packages:\r\n                            self._install_python_package(package, result)\r\n\r\n                # Create temporary Python file\r\n                with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False, dir=working_dir) as f:\r\n                    f.write(command)\r\n                    temp_file = f.name\r\n\r\n                try:\r\n                    # Execute Python file\r\n                    python_cmd = f\"{sys.executable} {temp_file}\"\r\n                    self._execute_shell(python_cmd, result, env, working_dir)\r\n                finally:\r\n                    # Clean up\r\n                    os.unlink(temp_file)\r\n\r\n            except Exception as e:\r\n                result[\"error\"] = f\"Python execution error: {str(e)}\"\r\n                result[\"stderr\"] = str(e)\r\n\r\n    def _execute_nodejs(self, command: str, result: Dict, env: Dict, working_dir: Path):\r\n        \"\"\"Execute Node.js/JavaScript code.\"\"\"\r\n        # Check if it's a file execution or inline code\r\n        if command.startswith('node ') or command.startswith('npm ') or command.startswith('yarn '):\r\n            # Direct command execution\r\n            self._execute_shell(command, result, env, working_dir)\r\n        else:\r\n            # Inline code execution\r\n            try:\r\n                # Check for missing packages\r\n                if self.auto_install_packages:\r\n                    missing_packages = self._detect_missing_node_packages(command)\r\n                    if missing_packages:\r\n                        result[\"warnings\"].append(f\"Installing missing packages: {', '.join(missing_packages)}\")\r\n                        for package in missing_packages:\r\n                            self._install_node_package(package, result, working_dir)\r\n\r\n                # Create temporary JS file\r\n                with tempfile.NamedTemporaryFile(mode='w', suffix='.js', delete=False, dir=working_dir) as f:\r\n                    f.write(command)\r\n                    temp_file = f.name\r\n\r\n                try:\r\n                    # Execute Node.js file\r\n                    node_cmd = f\"node {temp_file}\"\r\n                    self._execute_shell(node_cmd, result, env, working_dir)\r\n                finally:\r\n                    # Clean up\r\n                    os.unlink(temp_file)\r\n\r\n            except Exception as e:\r\n                result[\"error\"] = f\"Node.js execution error: {str(e)}\"\r\n                result[\"stderr\"] = str(e)\r\n\r\n    def _execute_git(self, command: str, result: Dict, env: Dict, working_dir: Path):\r\n        \"\"\"Execute Git commands with enhanced error handling.\"\"\"\r\n        # Add git-specific environment variables\r\n        env['GIT_TERMINAL_PROMPT'] = '0'  # Disable password prompts\r\n\r\n        # Execute git command\r\n        self._execute_shell(command, result, env, working_dir)\r\n\r\n        # Add git-specific suggestions for common errors\r\n        if not result[\"success\"]:\r\n            stderr_lower = result[\"stderr\"].lower()\r\n            if \"not a git repository\" in stderr_lower:\r\n                result[\"suggestions\"].append(\"Initialize a git repository with 'git init' or navigate to an existing repository\")\r\n            elif \"permission denied\" in stderr_lower:\r\n                result[\"suggestions\"].append(\"Check repository permissions or authentication credentials\")\r\n            elif \"could not resolve host\" in stderr_lower:\r\n                result[\"suggestions\"].append(\"Check network connection and repository URL\")\r\n\r\n    def _execute_package_install(self, command: str, result: Dict, env: Dict):\r\n        \"\"\"Execute package installation commands.\"\"\"\r\n        # Detect package manager\r\n        pm = self._detect_package_manager(command)\r\n\r\n        if pm == \"Auto-detect\":\r\n            # Try to detect from command\r\n            if 'pip' in command:\r\n                pm = 'pip'\r\n            elif 'npm' in command:\r\n                pm = 'npm'\r\n            elif 'yarn' in command:\r\n                pm = 'yarn'\r\n            elif 'apt' in command:\r\n                pm = 'apt-get'\r\n            elif 'brew' in command:\r\n                pm = 'brew'\r\n            else:\r\n                result[\"error\"] = \"Could not detect package manager\"\r\n                result[\"suggestions\"].append(\"Specify the package manager explicitly\")\r\n                return\r\n\r\n        # Execute installation\r\n        self._execute_shell(command, result, env, Path.cwd())\r\n\r\n        # Track installed packages\r\n        if result[\"success\"]:\r\n            packages = self._extract_package_names(command, pm)\r\n            result[\"packages_installed\"] = packages\r\n            if packages:\r\n                result[\"warnings\"].append(f\"Successfully installed: {', '.join(packages)}\")\r\n\r\n    def _detect_package_manager(self, command: str) -> str:\r\n        \"\"\"Detect which package manager to use.\"\"\"\r\n        if self.package_manager != \"Auto-detect\":\r\n            return self.package_manager\r\n\r\n        command_lower = command.lower()\r\n        if 'pip' in command_lower:\r\n            return 'pip'\r\n        elif 'npm' in command_lower:\r\n            return 'npm'\r\n        elif 'yarn' in command_lower:\r\n            return 'yarn'\r\n        elif 'apt-get' in command_lower or 'apt ' in command_lower:\r\n            return 'apt-get'\r\n        elif 'brew' in command_lower:\r\n            return 'brew'\r\n        elif 'dnf' in command_lower:\r\n            return 'dnf'\r\n        elif 'yum' in command_lower:\r\n            return 'yum'\r\n\r\n        return \"Auto-detect\"\r\n\r\n    def _detect_missing_python_packages(self, code: str) -> List[str]:\r\n        \"\"\"Detect missing Python packages from import statements.\"\"\"\r\n        missing = []\r\n        import_pattern = r'(?:from|import)\\s+(\\w+)'\r\n\r\n        for match in re.finditer(import_pattern, code):\r\n            package = match.group(1)\r\n            # Check if package is importable\r\n            try:\r\n                __import__(package)\r\n            except ImportError:\r\n                # Map common aliases to actual package names\r\n                package_map = {\r\n                    'cv2': 'opencv-python',\r\n                    'sklearn': 'scikit-learn',\r\n                    'PIL': 'Pillow',\r\n                    'yaml': 'PyYAML'\r\n                }\r\n                actual_package = package_map.get(package, package)\r\n                if actual_package not in missing:\r\n                    missing.append(actual_package)\r\n\r\n        return missing\r\n\r\n    def _detect_missing_node_packages(self, code: str) -> List[str]:\r\n        \"\"\"Detect missing Node.js packages from require statements.\"\"\"\r\n        missing = []\r\n        require_pattern = r'require\\([\\'\"](\\w+)[\\'\"]\\)'\r\n        import_pattern = r'import\\s+.*\\s+from\\s+[\\'\"](\\w+)[\\'\"]'\r\n\r\n        patterns = [require_pattern, import_pattern]\r\n        for pattern in patterns:\r\n            for match in re.finditer(pattern, code):\r\n                package = match.group(1)\r\n                # Check if package exists (simplified check)\r\n                check_cmd = f\"npm list {package} --depth=0\"\r\n                result = subprocess.run(check_cmd, shell=True, capture_output=True)\r\n                if result.returncode != 0 and package not in missing:\r\n                    missing.append(package)\r\n\r\n        return missing\r\n\r\n    def _install_python_package(self, package: str, result: Dict):\r\n        \"\"\"Install a Python package.\"\"\"\r\n        cmd = f\"{sys.executable} -m pip install {package}\"\r\n        process = subprocess.run(cmd, shell=True, capture_output=True, text=True)\r\n        if process.returncode == 0:\r\n            result[\"packages_installed\"].append(package)\r\n        else:\r\n            result[\"warnings\"].append(f\"Failed to install {package}: {process.stderr}\")\r\n\r\n    def _install_node_package(self, package: str, result: Dict, working_dir: Path):\r\n        \"\"\"Install a Node.js package.\"\"\"\r\n        # Check if package.json exists\r\n        package_json = working_dir / \"package.json\"\r\n        if not package_json.exists():\r\n            # Initialize npm if needed\r\n            init_cmd = \"npm init -y\"\r\n            subprocess.run(init_cmd, shell=True, capture_output=True, cwd=str(working_dir))\r\n\r\n        cmd = f\"npm install {package}\"\r\n        process = subprocess.run(cmd, shell=True, capture_output=True, text=True, cwd=str(working_dir))\r\n        if process.returncode == 0:\r\n            result[\"packages_installed\"].append(package)\r\n        else:\r\n            result[\"warnings\"].append(f\"Failed to install {package}: {process.stderr}\")\r\n\r\n    def _extract_package_names(self, command: str, package_manager: str) -> List[str]:\r\n        \"\"\"Extract package names from install command.\"\"\"\r\n        packages = []\r\n\r\n        # Remove the package manager and install command\r\n        patterns = [\r\n            f'{package_manager} install',\r\n            f'{package_manager} add',\r\n            f'{package_manager} i'\r\n        ]\r\n\r\n        clean_cmd = command\r\n        for pattern in patterns:\r\n            clean_cmd = clean_cmd.replace(pattern, '').strip()\r\n\r\n        # Split by spaces and filter flags\r\n        for item in clean_cmd.split():\r\n            if not item.startswith('-') and item not in ['sudo', 'global', '-g']:\r\n                packages.append(item)\r\n\r\n        return packages\r\n\r\n    def _add_error_suggestions(self, command: str, stderr: str, result: Dict):\r\n        \"\"\"Add helpful suggestions based on error patterns.\"\"\"\r\n        stderr_lower = stderr.lower()\r\n\r\n        # Command not found\r\n        if \"command not found\" in stderr_lower or \"not recognized\" in stderr_lower:\r\n            cmd_parts = command.split()\r\n            if cmd_parts:\r\n                tool = cmd_parts[0]\r\n                result[\"suggestions\"].append(f\"The command '{tool}' is not installed or not in PATH\")\r\n\r\n                # Suggest installation commands\r\n                install_suggestions = {\r\n                    'git': 'Install git: apt-get install git (Linux) or brew install git (Mac)',\r\n                    'python': 'Install Python from python.org',\r\n                    'node': 'Install Node.js from nodejs.org',\r\n                    'npm': 'Comes with Node.js installation',\r\n                    'pip': 'Install pip: python -m ensurepip',\r\n                }\r\n\r\n                if tool in install_suggestions:\r\n                    result[\"suggestions\"].append(install_suggestions[tool])\r\n\r\n        # Permission denied\r\n        elif \"permission denied\" in stderr_lower:\r\n            result[\"suggestions\"].append(\"Try running with appropriate permissions or in a different directory\")\r\n            if platform.system() != \"Windows\":\r\n                result[\"suggestions\"].append(\"On Unix systems, you might need to use 'sudo' for system operations\")\r\n\r\n        # File not found\r\n        elif \"no such file\" in stderr_lower or \"cannot find\" in stderr_lower:\r\n            result[\"suggestions\"].append(\"Check that the file or directory exists and the path is correct\")\r\n            result[\"suggestions\"].append(f\"Current working directory: {Path.cwd()}\")\r\n\r\n        # Network errors\r\n        elif \"could not resolve\" in stderr_lower or \"connection\" in stderr_lower:\r\n            result[\"suggestions\"].append(\"Check your network connection\")\r\n            result[\"suggestions\"].append(\"Verify that the URL or hostname is correct\")\r\n\r\n    def _format_output(self, result: Dict) -> Any:\r\n        \"\"\"Format the output based on selected format.\"\"\"\r\n        format_type = self.output_format\r\n\r\n        if format_type == \"JSON\":\r\n            return result\r\n\r\n        elif format_type == \"Summary\":\r\n            summary = []\r\n            summary.append(f\"{'✓' if result['success'] else '✗'} Command: {result['command'][:50]}...\")\r\n            summary.append(f\"Mode: {result['mode']}\")\r\n            summary.append(f\"Exit Code: {result['exit_code']}\")\r\n            summary.append(f\"Execution Time: {result['execution_time']}s\")\r\n\r\n            if result.get('error'):\r\n                summary.append(f\"Error: {result['error']}\")\r\n\r\n            if result.get('packages_installed'):\r\n                summary.append(f\"Packages Installed: {', '.join(result['packages_installed'])}\")\r\n\r\n            if result.get('suggestions'):\r\n                summary.append(\"\\nSuggestions:\")\r\n                for suggestion in result['suggestions']:\r\n                    summary.append(f\"  • {suggestion}\")\r\n\r\n            return {\"output\": \"\\n\".join(summary)}\r\n\r\n        elif format_type == \"Stdout only\":\r\n            return {\"output\": result.get('stdout', '')}\r\n\r\n        elif format_type == \"Stderr only\":\r\n            return {\"output\": result.get('stderr', '')}\r\n\r\n        else:  # Full output\r\n            output_parts = []\r\n\r\n            if self.verbose:\r\n                # Add execution details\r\n                output_parts.append(\"=\" * 60)\r\n                output_parts.append(f\"EXECUTION DETAILS\")\r\n                output_parts.append(\"=\" * 60)\r\n                output_parts.append(f\"Command: {result['command']}\")\r\n                output_parts.append(f\"Mode: {result['mode']}\")\r\n                output_parts.append(f\"Working Directory: {result['working_directory']}\")\r\n                output_parts.append(f\"Timeout: {self.timeout}s\")\r\n                output_parts.append(f\"Security Mode: {self.security_mode}\")\r\n\r\n                if result['environment']:\r\n                    output_parts.append(f\"Environment Variables: {json.dumps(result['environment'], indent=2)}\")\r\n\r\n                output_parts.append(\"=\" * 60)\r\n                output_parts.append(\"\")\r\n\r\n            # Add warnings\r\n            if result.get('warnings'):\r\n                output_parts.append(\"⚠ WARNINGS:\")\r\n                for warning in result['warnings']:\r\n                    output_parts.append(f\"  {warning}\")\r\n                output_parts.append(\"\")\r\n\r\n            # Add stdout\r\n            if result.get('stdout'):\r\n                output_parts.append(\"STDOUT:\")\r\n                output_parts.append(\"-\" * 40)\r\n                output_parts.append(result['stdout'])\r\n                output_parts.append(\"\")\r\n\r\n            # Add stderr\r\n            if result.get('stderr'):\r\n                output_parts.append(\"STDERR:\")\r\n                output_parts.append(\"-\" * 40)\r\n                output_parts.append(result['stderr'])\r\n                output_parts.append(\"\")\r\n\r\n            # Add error if present\r\n            if result.get('error'):\r\n                output_parts.append(\"ERROR:\")\r\n                output_parts.append(\"-\" * 40)\r\n                output_parts.append(result['error'])\r\n                output_parts.append(\"\")\r\n\r\n            # Add execution metrics\r\n            if self.verbose:\r\n                output_parts.append(\"EXECUTION METRICS:\")\r\n                output_parts.append(\"-\" * 40)\r\n                output_parts.append(f\"Exit Code: {result['exit_code']}\")\r\n                output_parts.append(f\"Success: {result['success']}\")\r\n                output_parts.append(f\"Execution Time: {result['execution_time']} seconds\")\r\n\r\n                if result.get('packages_installed'):\r\n                    output_parts.append(f\"Packages Installed: {', '.join(result['packages_installed'])}\")\r\n                output_parts.append(\"\")\r\n\r\n            # Add suggestions\r\n            if result.get('suggestions'):\r\n                output_parts.append(\"💡 SUGGESTIONS:\")\r\n                for suggestion in result['suggestions']:\r\n                    output_parts.append(f\"  • {suggestion}\")\r\n\r\n            return {\"output\": \"\\n\".join(output_parts)}"
              },
              "command": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Command/Code",
                "dynamic": false,
                "info": "Shell command or code to execute. Supports multi-line input for scripts.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "command",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "environment_vars": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Environment Variables",
                "dynamic": false,
                "info": "Additional environment variables (KEY=VALUE format, one per line)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "environment_vars",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "execution_mode": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Execution Mode",
                "dynamic": false,
                "external_options": {},
                "info": "How to interpret and execute the command",
                "name": "execution_mode",
                "options": [
                  "Auto-detect",
                  "Shell",
                  "Python",
                  "Node.js",
                  "Package Install",
                  "Git"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Shell"
              },
              "output_format": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Output Format",
                "dynamic": false,
                "external_options": {},
                "info": "How to format the execution output",
                "name": "output_format",
                "options": [
                  "Full",
                  "Stdout only",
                  "Stderr only",
                  "Summary",
                  "JSON"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Full"
              },
              "package_manager": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Package Manager",
                "dynamic": false,
                "external_options": {},
                "info": "Package manager to use for installations",
                "name": "package_manager",
                "options": [
                  "Auto-detect",
                  "pip",
                  "pip3",
                  "npm",
                  "yarn",
                  "apt-get",
                  "apt",
                  "brew",
                  "dnf",
                  "yum"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Auto-detect"
              },
              "security_mode": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Security Mode",
                "dynamic": false,
                "external_options": {},
                "info": "Security level for command execution",
                "name": "security_mode",
                "options": [
                  "Safe (Recommended)",
                  "Unrestricted",
                  "Restricted",
                  "Read-only"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Unrestricted"
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Timeout (seconds)",
                "dynamic": false,
                "info": "Maximum execution time in seconds (0 = no timeout)",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 30
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "command": {
                        "default": "",
                        "description": "Shell command or code to execute. Supports multi-line input for scripts.",
                        "title": "Command",
                        "type": "string"
                      }
                    },
                    "description": "Executes shell commands, runs code in multiple languages, installs packages, and performs git operations with comprehensive security controls and verbose output.",
                    "display_description": "Executes shell commands, runs code in multiple languages, installs packages, and performs git operations with comprehensive security controls and verbose output.",
                    "display_name": "execute_command",
                    "name": "execute_command",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "execute_command"
                    ]
                  }
                ]
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Verbose Output",
                "dynamic": false,
                "info": "Include detailed execution information and metrics",
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "working_directory": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Working Directory",
                "dynamic": false,
                "info": "Directory to execute the command in (defaults to current directory)",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "working_directory",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": true
          },
          "showNode": true,
          "type": "CodeRunnerTool"
        },
        "dragging": false,
        "id": "CustomComponent-RBhOR",
        "measured": {
          "height": 621,
          "width": 320
        },
        "position": {
          "x": 1334.546891181112,
          "y": -581.9258602184026
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-PUNPu",
          "node": {
            "base_classes": [
              "Data",
              "Text"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Execute multiple browser actions in one session - maintains context throughout",
            "display_name": "Playwright Workflow",
            "documentation": "https://playwright.dev/python/",
            "edited": true,
            "field_order": [
              "actions_json",
              "start_url",
              "browser_type",
              "headless",
              "default_timeout",
              "auto_wait",
              "pierce_shadow_dom",
              "return_all_results"
            ],
            "frozen": false,
            "icon": "workflow",
            "last_updated": "2025-11-04T01:44:11.097Z",
            "legacy": false,
            "lf_version": "1.6.0",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "actions_json": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Actions (JSON Array)",
                "dynamic": false,
                "info": "JSON array of actions, e.g.: [{\"action\":\"navigate\",\"url\":\"https://example.com\"},{\"action\":\"extract_all_text\"}]",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "actions_json",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "auto_wait": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Auto Wait for Load",
                "dynamic": false,
                "info": "Automatically wait for network idle after navigation",
                "list": false,
                "list_add_label": "Add More",
                "name": "auto_wait",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "browser_type": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Browser",
                "dynamic": false,
                "external_options": {},
                "info": "Browser engine to use",
                "name": "browser_type",
                "options": [
                  "chromium",
                  "firefox",
                  "webkit"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "chromium"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "\"\"\"\nPlaywright Workflow Component for Langflow\nExecute multiple browser actions in a single session - perfect for AI agents!\n\"\"\"\n\nfrom typing import Optional, Dict, Any, List\nimport asyncio\nimport json\nimport base64\nfrom pathlib import Path\n\nfrom langflow.custom import Component\nfrom langflow.io import (\n    MessageTextInput,\n    StrInput,\n    BoolInput,\n    IntInput,\n    DropdownInput,\n    MultilineInput,\n    Output\n)\nfrom langflow.schema import Data, Message\nfrom playwright.async_api import async_playwright, Browser, Page, TimeoutError\n\n\nclass PlaywrightWorkflowComponent(Component):\n    \"\"\"\n    Execute a sequence of browser actions in a single session.\n    Perfect for AI agents that need to navigate, wait, and extract data.\n    \"\"\"\n\n    display_name = \"Playwright Workflow\"\n    description = \"Execute multiple browser actions in one session - maintains context throughout\"\n    icon = \"workflow\"\n    name = \"PlaywrightWorkflow\"\n    documentation = \"https://playwright.dev/python/\"\n\n    inputs = [\n        MultilineInput(\n            name=\"actions_json\",\n            display_name=\"Actions (JSON Array)\",\n            info='JSON array of actions, e.g.: [{\"action\":\"navigate\",\"url\":\"https://example.com\"},{\"action\":\"extract_all_text\"}]',\n            required=True,\n            tool_mode=True,\n        ),\n        StrInput(\n            name=\"start_url\",\n            display_name=\"Start URL (Optional)\",\n            info=\"Initial URL to navigate to before running actions\",\n            required=False,\n            tool_mode=True,\n        ),\n        DropdownInput(\n            name=\"browser_type\",\n            display_name=\"Browser\",\n            options=[\"chromium\", \"firefox\", \"webkit\"],\n            value=\"chromium\",\n            info=\"Browser engine to use\",\n        ),\n        BoolInput(\n            name=\"headless\",\n            display_name=\"Headless Mode\",\n            value=True,\n            info=\"Run browser without UI\",\n        ),\n        IntInput(\n            name=\"default_timeout\",\n            display_name=\"Default Timeout (ms)\",\n            value=30000,\n            info=\"Default timeout for all actions\",\n        ),\n        BoolInput(\n            name=\"auto_wait\",\n            display_name=\"Auto Wait for Load\",\n            value=True,\n            info=\"Automatically wait for network idle after navigation\",\n        ),\n        BoolInput(\n            name=\"pierce_shadow_dom\",\n            display_name=\"Pierce Shadow DOM\",\n            value=True,\n            info=\"Enable Shadow DOM piercing for sites like YouTube\",\n        ),\n        BoolInput(\n            name=\"return_all_results\",\n            display_name=\"Return All Results\",\n            value=True,\n            info=\"Return results from all actions (vs just the last one)\",\n        ),\n    ]\n\n    outputs = [\n        Output(\n            display_name=\"Results\",\n            name=\"results\",\n            method=\"execute_workflow\"\n        ),\n        Output(\n            display_name=\"Tool Output\",\n            name=\"tool_output\",\n            method=\"get_tool_output\"\n        ),\n    ]\n\n    async def _execute_action_in_page(self, page: Page, action_def: Dict[str, Any], step_num: int) -> Dict[str, Any]:\n        \"\"\"Execute a single action within the current page context\"\"\"\n\n        action = action_def.get(\"action\", \"\")\n\n        # Get action-specific parameters\n        url = action_def.get(\"url\", \"\")\n        selector = action_def.get(\"selector\", \"\")\n        value = action_def.get(\"value\", \"\")\n        javascript = action_def.get(\"javascript\", \"\")\n        timeout = action_def.get(\"timeout\", self.default_timeout)\n        attribute = action_def.get(\"attribute\", \"\")\n\n        try:\n            # NAVIGATION\n            if action == \"navigate\":\n                if not url:\n                    return {\"error\": \"URL required for navigate\", \"step\": step_num}\n\n                wait_until = \"networkidle\" if self.auto_wait else \"load\"\n                response = await page.goto(url, timeout=timeout, wait_until=wait_until)\n\n                return {\n                    \"step\": step_num,\n                    \"action\": \"navigate\",\n                    \"url\": page.url,\n                    \"title\": await page.title(),\n                    \"status\": response.status if response else None,\n                    \"success\": True\n                }\n\n            # WAIT FOR SELECTOR\n            elif action == \"wait_for_selector\":\n                if not selector:\n                    return {\"error\": \"Selector required\", \"step\": step_num}\n\n                await page.wait_for_selector(selector, timeout=timeout)\n                return {\n                    \"step\": step_num,\n                    \"action\": \"wait_for_selector\",\n                    \"selector\": selector,\n                    \"success\": True\n                }\n\n            # CLICK\n            elif action == \"click\":\n                if not selector:\n                    return {\"error\": \"Selector required\", \"step\": step_num}\n\n                await page.click(selector, timeout=timeout)\n                return {\n                    \"step\": step_num,\n                    \"action\": \"click\",\n                    \"selector\": selector,\n                    \"success\": True\n                }\n\n            # FILL\n            elif action == \"fill\":\n                if not selector or not value:\n                    return {\"error\": \"Selector and value required\", \"step\": step_num}\n\n                await page.fill(selector, value, timeout=timeout)\n                return {\n                    \"step\": step_num,\n                    \"action\": \"fill\",\n                    \"selector\": selector,\n                    \"success\": True\n                }\n\n            # EXTRACT TEXT\n            elif action == \"extract_text\":\n                if not selector:\n                    return {\"error\": \"Selector required\", \"step\": step_num}\n\n                # Try with Shadow DOM piercing if enabled\n                if self.pierce_shadow_dom:\n                    text = await page.evaluate(f\"\"\"() => {{\n                        const el = document.querySelector('{selector}');\n                        if (el) return el.textContent?.trim();\n                        // Try shadow DOM\n                        const shadowHosts = document.querySelectorAll('*');\n                        for (let host of shadowHosts) {{\n                            if (host.shadowRoot) {{\n                                const shadowEl = host.shadowRoot.querySelector('{selector}');\n                                if (shadowEl) return shadowEl.textContent?.trim();\n                            }}\n                        }}\n                        return null;\n                    }}\"\"\")\n                else:\n                    element = await page.wait_for_selector(selector, timeout=timeout)\n                    text = await element.inner_text() if element else None\n\n                return {\n                    \"step\": step_num,\n                    \"action\": \"extract_text\",\n                    \"selector\": selector,\n                    \"text\": text,\n                    \"success\": True\n                }\n\n            # EXTRACT ALL TEXT\n            elif action == \"extract_all_text\":\n                text = await page.inner_text(\"body\")\n                return {\n                    \"step\": step_num,\n                    \"action\": \"extract_all_text\",\n                    \"text\": text,\n                    \"length\": len(text),\n                    \"success\": True\n                }\n\n            # EXTRACT ATTRIBUTE\n            elif action == \"extract_attribute\":\n                if not selector or not attribute:\n                    return {\"error\": \"Selector and attribute required\", \"step\": step_num}\n\n                attr_value = await page.get_attribute(selector, attribute)\n                return {\n                    \"step\": step_num,\n                    \"action\": \"extract_attribute\",\n                    \"selector\": selector,\n                    \"attribute\": attribute,\n                    \"value\": attr_value,\n                    \"success\": True\n                }\n\n            # EXECUTE JAVASCRIPT\n            elif action == \"execute_js\":\n                if not javascript:\n                    return {\"error\": \"JavaScript code required\", \"step\": step_num}\n\n                result = await page.evaluate(javascript)\n                return {\n                    \"step\": step_num,\n                    \"action\": \"execute_js\",\n                    \"result\": result,\n                    \"success\": True\n                }\n\n            # SCREENSHOT\n            elif action == \"screenshot\":\n                screenshot_bytes = await page.screenshot(full_page=True)\n                screenshot_b64 = base64.b64encode(screenshot_bytes).decode('utf-8')\n                return {\n                    \"step\": step_num,\n                    \"action\": \"screenshot\",\n                    \"screenshot_base64\": screenshot_b64,\n                    \"size_bytes\": len(screenshot_bytes),\n                    \"success\": True\n                }\n\n            # EXTRACT LINKS\n            elif action == \"extract_links\":\n                links = await page.eval_on_selector_all(\n                    \"a[href]\",\n                    \"elements => elements.map(e => ({text: e.innerText?.trim(), href: e.href}))\"\n                )\n                return {\n                    \"step\": step_num,\n                    \"action\": \"extract_links\",\n                    \"links\": links,\n                    \"count\": len(links),\n                    \"success\": True\n                }\n\n            # WAIT (simple delay)\n            elif action == \"wait\":\n                wait_ms = action_def.get(\"ms\", 1000)\n                await page.wait_for_timeout(wait_ms)\n                return {\n                    \"step\": step_num,\n                    \"action\": \"wait\",\n                    \"ms\": wait_ms,\n                    \"success\": True\n                }\n\n            # SCROLL\n            elif action == \"scroll_to\":\n                if selector:\n                    await page.eval_on_selector(\n                        selector,\n                        \"el => el.scrollIntoView({behavior: 'smooth', block: 'center'})\"\n                    )\n                else:\n                    # Scroll to bottom\n                    await page.evaluate(\"window.scrollTo(0, document.body.scrollHeight)\")\n\n                return {\n                    \"step\": step_num,\n                    \"action\": \"scroll_to\",\n                    \"selector\": selector if selector else \"bottom\",\n                    \"success\": True\n                }\n\n            # HOVER\n            elif action == \"hover\":\n                if not selector:\n                    return {\"error\": \"Selector required\", \"step\": step_num}\n\n                await page.hover(selector, timeout=timeout)\n                return {\n                    \"step\": step_num,\n                    \"action\": \"hover\",\n                    \"selector\": selector,\n                    \"success\": True\n                }\n\n            # GET CURRENT URL\n            elif action == \"get_url\":\n                return {\n                    \"step\": step_num,\n                    \"action\": \"get_url\",\n                    \"url\": page.url,\n                    \"title\": await page.title(),\n                    \"success\": True\n                }\n\n            else:\n                return {\n                    \"step\": step_num,\n                    \"error\": f\"Unknown action: {action}\",\n                    \"success\": False\n                }\n\n        except TimeoutError as e:\n            return {\n                \"step\": step_num,\n                \"action\": action,\n                \"error\": f\"Timeout: {str(e)}\",\n                \"success\": False\n            }\n        except Exception as e:\n            return {\n                \"step\": step_num,\n                \"action\": action,\n                \"error\": str(e),\n                \"type\": type(e).__name__,\n                \"success\": False\n            }\n\n    async def _run_workflow(self) -> Dict[str, Any]:\n        \"\"\"Execute the workflow with multiple actions in one browser session\"\"\"\n\n        # Parse actions\n        try:\n            if isinstance(self.actions_json, str):\n                actions = json.loads(self.actions_json)\n            else:\n                actions = self.actions_json\n        except json.JSONDecodeError as e:\n            return {\n                \"error\": f\"Invalid JSON in actions: {str(e)}\",\n                \"success\": False\n            }\n\n        if not isinstance(actions, list):\n            return {\n                \"error\": \"Actions must be a JSON array\",\n                \"success\": False\n            }\n\n        # Launch browser\n        async with async_playwright() as p:\n            browser_type = getattr(p, getattr(self, 'browser_type', 'chromium'))\n            browser: Browser = await browser_type.launch(\n                headless=getattr(self, 'headless', True)\n            )\n\n            context = await browser.new_context(\n                viewport={\"width\": 1280, \"height\": 720}\n            )\n            page: Page = await context.new_page()\n\n            try:\n                results = []\n\n                # Navigate to start URL if provided\n                start_url = getattr(self, 'start_url', None)\n                if start_url:\n                    wait_until = \"networkidle\" if self.auto_wait else \"load\"\n                    await page.goto(start_url, wait_until=wait_until)\n                    results.append({\n                        \"step\": 0,\n                        \"action\": \"navigate\",\n                        \"url\": start_url,\n                        \"success\": True,\n                        \"note\": \"Initial navigation from start_url parameter\"\n                    })\n\n                # Execute each action sequentially\n                for i, action_def in enumerate(actions, start=1):\n                    result = await self._execute_action_in_page(page, action_def, i)\n                    results.append(result)\n\n                    # Stop on error unless configured otherwise\n                    if not result.get(\"success\", False):\n                        break\n\n                # Summary\n                total_actions = len(results)\n                successful_actions = sum(1 for r in results if r.get(\"success\"))\n\n                return {\n                    \"success\": successful_actions == total_actions,\n                    \"total_actions\": total_actions,\n                    \"successful_actions\": successful_actions,\n                    \"failed_actions\": total_actions - successful_actions,\n                    \"results\": results if self.return_all_results else results[-1:],\n                    \"final_url\": page.url,\n                    \"final_title\": await page.title()\n                }\n\n            except Exception as e:\n                return {\n                    \"error\": str(e),\n                    \"type\": type(e).__name__,\n                    \"success\": False\n                }\n            finally:\n                await context.close()\n                await browser.close()\n\n    def execute_workflow(self) -> Data:\n        \"\"\"Main entry point for workflow execution\"\"\"\n        try:\n            # Run async workflow\n            try:\n                import nest_asyncio\n                nest_asyncio.apply()\n                loop = asyncio.get_event_loop()\n                result = loop.run_until_complete(self._run_workflow())\n            except ImportError:\n                result = asyncio.run(self._run_workflow())\n\n            # Update status\n            if result.get(\"success\"):\n                self.status = f\"Workflow completed: {result.get('successful_actions', 0)}/{result.get('total_actions', 0)} actions\"\n            else:\n                self.status = f\"Workflow failed: {result.get('error', 'Unknown error')}\"\n\n            return Data(\n                data=result,\n                text=json.dumps(result, indent=2, default=str)\n            )\n\n        except Exception as e:\n            self.status = f\"Failed: {str(e)}\"\n            return Data(\n                data={\"error\": str(e), \"success\": False},\n                text=json.dumps({\"error\": str(e)}, indent=2)\n            )\n\n    def get_tool_output(self) -> str:\n        \"\"\"Get tool output for agent integration\"\"\"\n        result = self.execute_workflow()\n        return result.text\n"
              },
              "default_timeout": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Default Timeout (ms)",
                "dynamic": false,
                "info": "Default timeout for all actions",
                "list": false,
                "list_add_label": "Add More",
                "name": "default_timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 30000
              },
              "headless": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Headless Mode",
                "dynamic": false,
                "info": "Run browser without UI",
                "list": false,
                "list_add_label": "Add More",
                "name": "headless",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "pierce_shadow_dom": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Pierce Shadow DOM",
                "dynamic": false,
                "info": "Enable Shadow DOM piercing for sites like YouTube",
                "list": false,
                "list_add_label": "Add More",
                "name": "pierce_shadow_dom",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "return_all_results": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Return All Results",
                "dynamic": false,
                "info": "Return results from all actions (vs just the last one)",
                "list": false,
                "list_add_label": "Add More",
                "name": "return_all_results",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "start_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Start URL (Optional)",
                "dynamic": false,
                "info": "Initial URL to navigate to before running actions",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "start_url",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "actions_json": {
                        "description": "JSON array of actions, e.g.: [{\"action\":\"navigate\",\"url\":\"https://example.com\"},{\"action\":\"extract_all_text\"}]",
                        "title": "Actions Json",
                        "type": "string"
                      },
                      "start_url": {
                        "default": "",
                        "description": "Initial URL to navigate to before running actions",
                        "title": "Start Url",
                        "type": "string"
                      }
                    },
                    "description": "Execute multiple browser actions in one session - maintains context throughout",
                    "display_description": "Execute multiple browser actions in one session - maintains context throughout",
                    "display_name": "execute_workflow",
                    "name": "execute_workflow",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "execute_workflow"
                    ]
                  },
                  {
                    "args": {
                      "actions_json": {
                        "description": "JSON array of actions, e.g.: [{\"action\":\"navigate\",\"url\":\"https://example.com\"},{\"action\":\"extract_all_text\"}]",
                        "title": "Actions Json",
                        "type": "string"
                      },
                      "start_url": {
                        "default": "",
                        "description": "Initial URL to navigate to before running actions",
                        "title": "Start Url",
                        "type": "string"
                      }
                    },
                    "description": "Execute multiple browser actions in one session - maintains context throughout",
                    "display_description": "Execute multiple browser actions in one session - maintains context throughout",
                    "display_name": "get_tool_output",
                    "name": "get_tool_output",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "get_tool_output"
                    ]
                  }
                ]
              }
            },
            "tool_mode": true
          },
          "selected_output": "result",
          "showNode": true,
          "type": "PlaywrightWorkflow"
        },
        "dragging": false,
        "id": "CustomComponent-PUNPu",
        "measured": {
          "height": 549,
          "width": 320
        },
        "position": {
          "x": 1764.690438791927,
          "y": -646.125235630454
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "note-EHQKg",
          "node": {
            "description": " ",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-EHQKg",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 2483.2130227560274,
          "y": -646.0974690472534
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-k9VBv",
          "node": {
            "description": " ",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-k9VBv",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 2584.553080525472,
          "y": -478.58292884447576
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-RT3On",
          "node": {
            "description": "",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "height": 649,
        "id": "note-RT3On",
        "measured": {
          "height": 649,
          "width": 966
        },
        "position": {
          "x": 1615.309382813252,
          "y": -712.3994334422529
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 966
      },
      {
        "data": {
          "id": "note-ZTPkZ",
          "node": {
            "description": " ",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "height": 554,
        "id": "note-ZTPkZ",
        "measured": {
          "height": 554,
          "width": 575
        },
        "position": {
          "x": 1470.3989831438087,
          "y": -710.1936173611417
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 575
      },
      {
        "data": {
          "id": "note-rRVtD",
          "node": {
            "description": " ",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "height": 641,
        "id": "note-rRVtD",
        "measured": {
          "height": 641,
          "width": 402
        },
        "position": {
          "x": 1318.721120847142,
          "y": -632.9900545222531
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 402
      },
      {
        "data": {
          "id": "note-yZBE8",
          "node": {
            "description": " ",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "height": 459,
        "id": "note-yZBE8",
        "measured": {
          "height": 459,
          "width": 324
        },
        "position": {
          "x": 1328.3408223326978,
          "y": -58.37496539281
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 324
      },
      {
        "data": {
          "id": "note-eQXEX",
          "node": {
            "description": " ",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "height": 529,
        "id": "note-eQXEX",
        "measured": {
          "height": 529,
          "width": 326
        },
        "position": {
          "x": 2110.302623086585,
          "y": -138.88725235336557
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 326
      },
      {
        "data": {
          "id": "note-tUrnN",
          "node": {
            "description": " ",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "height": 324,
        "id": "note-tUrnN",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 2867.124025152745,
          "y": -957.7672857906159
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 324
      },
      {
        "data": {
          "id": "note-RV6Ni",
          "node": {
            "description": " ",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-RV6Ni",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 2715.1273835454613,
          "y": -765.5443356440209
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-nNKnM",
          "node": {
            "description": " ",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "height": 633,
        "id": "note-nNKnM",
        "measured": {
          "height": 633,
          "width": 412
        },
        "position": {
          "x": 2273.533013088806,
          "y": -678.2092841850306
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 412
      },
      {
        "data": {
          "id": "note-P2oIY",
          "node": {
            "description": "",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": false,
        "height": 800,
        "id": "note-P2oIY",
        "measured": {
          "height": 800,
          "width": 1000
        },
        "position": {
          "x": 4576.847018526996,
          "y": -2830.9789553548444
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 1000
      },
      {
        "data": {
          "id": "note-g5tum",
          "node": {
            "description": "",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": false,
        "height": 335,
        "id": "note-g5tum",
        "measured": {
          "height": 335,
          "width": 778
        },
        "position": {
          "x": 3572.745261738675,
          "y": -2588.747657702936
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 778
      },
      {
        "data": {
          "id": "note-kbp9F",
          "node": {
            "description": "",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-kbp9F",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 3970.5943867394185,
          "y": -3140.6959758823223
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-sMK5h",
          "node": {
            "description": "",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": false,
        "height": 789,
        "id": "note-sMK5h",
        "measured": {
          "height": 789,
          "width": 324
        },
        "position": {
          "x": 4823.36598900924,
          "y": -3719.0211057520655
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 324
      },
      {
        "data": {
          "id": "note-zKEO7",
          "node": {
            "description": "",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-zKEO7",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 5636.473795824652,
          "y": -3186.026027830219
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-w99PV",
          "node": {
            "description": "",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-w99PV",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 4109.422592908008,
          "y": -1874.1195473151402
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-QOjd4",
          "node": {
            "description": "",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-QOjd4",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 5619.475026344191,
          "y": -1925.2839580293194
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-yKl87",
          "node": {
            "description": "",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": false,
        "height": 800,
        "id": "note-yKl87",
        "measured": {
          "height": 800,
          "width": 343
        },
        "position": {
          "x": 4860.196656216907,
          "y": -1840.2901106270124
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 343
      },
      {
        "data": {
          "id": "note-DbyZC",
          "node": {
            "description": "",
            "display_name": "",
            "documentation": "",
            "template": {}
          },
          "type": "note"
        },
        "dragging": false,
        "height": 324,
        "id": "note-DbyZC",
        "measured": {
          "height": 324,
          "width": 777
        },
        "position": {
          "x": 5720.650511734217,
          "y": -2596.7353525075523
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode",
        "width": 777
      }
    ],
    "viewport": {
      "x": -1834.675300889729,
      "y": 1094.4836462296666,
      "zoom": 1.1730927493537202
    }
  },
  "description": "A simple but powerful starter agent.",
  "endpoint_name": null,
  "id": "5a9582f6-dd9a-4ef9-93c0-06edce78b551",
  "is_component": false,
  "last_tested_version": "1.6.0",
  "name": "Elephant v1.0",
  "tags": [
    "assistants",
    "agents"
  ]
}